<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,minimum-scale=1,user-scalable=no" />
  <title>tuankhoi.site - HTML Editor</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@500;700;800;900&display=swap" rel="stylesheet">

  <style>
    :root{
      --bg1:#ffecd2; --bg2:#fcb69f;
      --card:#fff; --text:#1f2937; --muted:#6b7280;
      --border:#e5e7eb; --soft:#f8fafc;
      --shadow:0 14px 40px rgba(0,0,0,.10);
      --radius:18px;
      --bad:#dc2626;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;

      --codeBg:#0b1020;
      --codeText:#e5e7eb;
      --codeMuted:rgba(255,255,255,.55);
      --codeSoft:rgba(255,255,255,.06);

      --fs:13px;
      --lh:22px;
      --pad:12px;
      --gutterW:44px;

      --blue:#2563eb;
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    html{-webkit-text-size-adjust:100%}

    body{
      margin:0;
      font-family:"Montserrat",system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      color:var(--text);
      overflow-x:hidden;
      touch-action:pan-y;
      -webkit-overflow-scrolling:touch;
      user-select:none;

      background-color: var(--bg1);
      background-image:
        radial-gradient(1200px 600px at 20% 10%,#fff 0%,rgba(255,255,255,0) 55%),
        linear-gradient(120deg,var(--bg1) 0%,var(--bg2) 100%);
      background-attachment: fixed, fixed;
      background-repeat: no-repeat, no-repeat;
      background-size: cover, cover;
    }

    .wrap{max-width:980px;margin:0 auto;padding:12px 14px 26px}

    .pathBar{
      display:flex;
      align-items:center;
      gap:10px;
      padding:6px 8px;
      margin:2px 0 10px;
      user-select:none;
      min-width:0;
    }
    .pathText{
      font-weight:900;
      font-size:.86rem;
      color:rgba(31,41,55,.78);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      min-width:0;
    }

    .card{
      background:var(--card);
      border:2px solid var(--border);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      padding:12px;
      margin:0 0 12px;
    }

    .toolbarTop,.toolbarBottom{
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:nowrap;
      overflow:hidden;
      user-select:none;
    }
    .toolbarTop{justify-content:space-between}
    .toolbarBottom{justify-content:space-between}

    .toolbarLeft{display:flex;align-items:center;gap:10px;min-width:0}
    .toolbarRight{display:flex;align-items:center;gap:10px;flex:0 0 auto}

    .toolbarDivider{
      height:1px;
      background:rgba(229,231,235,.9);
      margin:10px 0;
      border-radius:999px;
    }

    .findGroup{
      flex:1 1 auto;
      min-width:160px;
      display:flex;
      gap:8px;
      flex-wrap:nowrap;
      align-items:center;
    }

    .input{
      width:100%;
      border-radius:14px;
      border:2px solid #e5e7eb;
      padding:9px 10px;
      font-size:.9rem;
      font-weight:750;
      outline:none;
      background:var(--soft);
      transition:border-color .15s ease,box-shadow .15s ease,background .15s ease;
      user-select:text;
    }
    .input:focus{
      border-color:rgba(124,58,237,.55);
      box-shadow:0 0 0 5px rgba(124,58,237,.10);
      background:#fff;
    }

    .btn{
      flex:0 0 auto;
      border:0;
      cursor:pointer;
      border-radius:999px;
      padding:9px 12px;
      font-weight:900;
      font-size:.88rem;
      background:#fff;
      color:#111827;
      border:1px solid #e5e7eb;
      user-select:none;
      white-space:nowrap;
      -webkit-tap-highlight-color:transparent;
      touch-action:manipulation;
      transition:transform .16s ease,filter .16s ease,opacity .16s ease;
    }
    .btn:hover{transform:translateY(-1px);filter:brightness(.98)}
    .btn:active{transform:translateY(0)}
    .btnGhost{
      background:#fff;
      color:#111827;
      border:1px solid #e5e7eb;
    }
    .btnPrimary{
      background:linear-gradient(135deg,#7c3aed,#fb7185);
      color:#fff;
      border:0;
    }
    .btnBlue{
      background:var(--blue);
      color:#fff;
      border:0;
      box-shadow:0 12px 24px rgba(37,99,235,.18);
    }
    .btnDanger{
      background:#fff;
      color:#b91c1c;
      border:1px solid rgba(185,28,28,.35);
    }
    .btnMini{
      padding:9px 10px;
      min-width:44px;
      text-align:center;
    }
    .btn[disabled]{opacity:.55;cursor:not-allowed;transform:none !important;filter:none !important}

    .errorBar{
      margin-top:10px;
      display:none;
      padding:10px 12px;
      border-radius:14px;
      border:1px solid rgba(220,38,38,.35);
      background:rgba(254,242,242,.85);
      color:#7f1d1d;
      font-weight:900;
      font-size:.9rem;
      user-select:none;
      cursor:pointer;
    }
    .errorBar.show{display:block}

    .sectionHead{
      margin-top:10px;
      margin-bottom:8px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      user-select:none;
    }
    .sectionTitle{
      font-weight:950;
      font-size:.92rem;
      color:rgba(31,41,55,.70);
      user-select:none;
    }

    .optBtn{
      border:0;
      background:transparent;
      padding:4px 8px;
      border-radius:10px;
      font-weight:950;
      font-size:1.02rem;
      cursor:pointer;
      user-select:none;
      -webkit-tap-highlight-color:transparent;
      touch-action:manipulation;
      color:#111827;
      opacity:1;
      transition:opacity .16s ease,transform .16s ease,filter .16s ease;
    }
    .optBtn:hover{transform:translateY(-1px);filter:brightness(.98)}
    .optBtn:active{transform:translateY(0)}
    .optBtn[disabled]{opacity:.35;cursor:not-allowed;transform:none !important;filter:none !important}

    .editorFrame{
      border-radius:16px;
      border:2px solid #e5e7eb;
      overflow:hidden;
      background:var(--codeBg);
      box-shadow:0 14px 34px rgba(0,0,0,.18);
      display:flex;
      align-items:stretch;
    }

    .gutter{
      width:var(--gutterW);
      flex:0 0 var(--gutterW);
      padding:var(--pad) 6px;
      background:var(--codeSoft);
      border-right:1px solid rgba(255,255,255,.10);
      color:var(--codeMuted);
      font-family:var(--mono);
      font-size:var(--fs);
      line-height:var(--lh);
      text-align:right;
      user-select:none;
    }
    .gline{
      height:var(--lh);
      display:flex;
      align-items:center;
      justify-content:flex-end;
      padding-right:2px;
    }
    .gline.err{
      background:rgba(220,38,38,.18);
      border-radius:8px;
      padding-right:6px;
      margin-right:-2px;
      margin-left:-2px;
    }

    .codePane{
      position:relative;
      flex:1 1 auto;
      width:100%;
      background:transparent;
    }

    pre.codeHl{
      position:absolute;
      inset:0;
      margin:0;
      padding:var(--pad);
      border:0;
      outline:none;
      background:transparent;
      color:var(--codeText);
      font-family:var(--mono);
      font-size:var(--fs);
      line-height:var(--lh);
      tab-size:2;

      white-space:pre-wrap;
      overflow-wrap:anywhere;
      word-break:break-word;

      pointer-events:none;
      user-select:none;
      opacity:1;
      transition:opacity .06s linear;
    }

    textarea.code{
      position:relative;
      width:100%;
      border:0;
      outline:none;
      resize:none;
      padding:var(--pad);
      background:transparent;

      font-family:var(--mono);
      font-size:var(--fs);
      line-height:var(--lh);
      tab-size:2;

      color:transparent;
      -webkit-text-fill-color:transparent;
      caret-color:#fff;

      overflow:hidden;
      white-space:pre-wrap;
      overflow-wrap:anywhere;
      word-break:break-word;

      user-select:text;
      touch-action:pan-y;
      -webkit-overflow-scrolling:touch;
    }
    textarea.code::selection{background:rgba(37,99,235,.33)}

    .codePane.typing pre.codeHl{opacity:0}
    .codePane.typing textarea.code{
      color:var(--codeText);
      -webkit-text-fill-color:var(--codeText);
    }

    .tok-punc{color:rgba(255,255,255,.70)}
    .tok-tag{color:#60a5fa}
    .tok-attr{color:#fbbf24}
    .tok-op{color:rgba(255,255,255,.60)}
    .tok-str{color:#34d399}
    .tok-com{color:rgba(255,255,255,.45)}
    .tok-doctype{color:#a78bfa}
    .tok-txt{color:rgba(229,231,235,.92)}

    .tok-find{
      background:rgba(37,99,235,.22);
      border-radius:7px;
      padding:0 1px;
      box-shadow:0 0 0 1px rgba(37,99,235,.18) inset;
    }
    .tok-find.active{
      background:rgba(37,99,235,.45);
      box-shadow:0 0 0 1px rgba(37,99,235,.30) inset;
    }

    .previewCard{padding:12px}
    .previewHead{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      user-select:none;
    }
    .previewLabel{
      font-weight:950;
      color:rgba(31,41,55,.65);
      font-size:.88rem;
      user-select:none;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .previewBox{
      margin-top:10px;
      border-radius:16px;
      border:2px solid #e5e7eb;
      background:#fff;
      overflow:hidden;
      height:30vh;
      min-height:200px;
      box-shadow:0 10px 22px rgba(0,0,0,.06);
    }
    .previewBox iframe{width:100%;height:100%;border:0;background:#fff}

    .toast{
      position:fixed;
      left:50%;
      bottom:18px;
      transform:translateX(-50%);
      background:rgba(17,24,39,.92);
      color:#fff;
      padding:10px 12px;
      border-radius:14px;
      font-weight:900;
      font-size:.9rem;
      opacity:0;
      pointer-events:none;
      transition:opacity .18s ease,transform .18s ease;
      max-width:calc(100% - 28px);
      z-index:20050;
      text-align:center;
      user-select:none;
    }
    .toast.show{opacity:1;transform:translateX(-50%) translateY(-4px)}

    @media(max-width:520px){
      :root{ --gutterW:40px; --fs:12.5px; --lh:21px; }
      .btn{padding:9px 10px}
      .btnMini{min-width:42px}
      .previewBox{height:34vh}
      .pathText{font-size:.84rem}
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="pathBar">
      <div class="pathText" id="filePath">—</div>
    </div>

    <div class="card">
      <div class="toolbarTop" id="toolbarTop">
        <div class="toolbarLeft">
          <button class="btn btnGhost" id="btnExit" type="button">Thoát</button>
        </div>

        <div class="toolbarRight">
          <button class="btn btnGhost" id="btnRevert" type="button">Hoàn tác</button>
          <button class="btn btnBlue" id="btnDownload" type="button">Tải về máy</button>
        </div>
      </div>

      <div class="toolbarDivider"></div>

      <div class="toolbarBottom" id="toolbarBottom">
        <div class="findGroup" id="findGroup">
          <input class="input" id="findInput" placeholder="Tìm trong..." autocomplete="off" />
          <button class="btn btnGhost" id="btnFind" type="button" disabled>Tìm</button>
          <button class="btn btnGhost btnMini" id="btnFindNext" type="button" style="display:none">⇧</button>
        </div>

        <div class="toolbarRight">
          <button class="btn btnPrimary" id="btnSave" type="button">Lưu</button>
          <button class="btn btnDanger" id="btnClearAll" type="button">Xoá tất cả</button>
        </div>
      </div>

      <div class="errorBar" id="errorBar"></div>

      <div class="sectionHead">
        <div class="sectionTitle">Code</div>
        <button class="optBtn" id="btnFormat" type="button" disabled>Căn chỉnh ⌥</button>
      </div>

      <div class="editorFrame" id="editorFrame">
        <div class="gutter" id="gutter"></div>

        <div class="codePane" id="codePane">
          <pre class="codeHl" id="codeHl" aria-hidden="true"></pre>
          <textarea class="code" id="code" spellcheck="false" wrap="soft"></textarea>
        </div>
      </div>
    </div>

    <div class="card previewCard">
      <div class="previewHead">
        <div class="previewLabel" id="previewLabel">Xem trước</div>
      </div>
      <div class="previewBox">
        <iframe id="preview" sandbox="allow-forms allow-modals allow-pointer-lock allow-popups allow-same-origin allow-scripts"></iframe>
      </div>
    </div>
  </div>

  <div class="toast" id="toast"></div>

  <div id="measure" style="
    position:absolute; left:-99999px; top:-99999px; visibility:hidden;
    white-space:pre-wrap; overflow-wrap:anywhere; word-break:break-word;
    font-family: var(--mono); font-size: var(--fs); line-height: var(--lh);
    tab-size:2; padding:0; margin:0;
  "></div>

  <script>
    const SUPABASE_URL = "https://aidvlydhbdtwunyreqak.supabase.co";
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImFpZHZseWRoYmR0d3VueXJlcWFrIiwicm9sZSI6ImFub24iLCJpYXQiOjE3Njg2MzM5NzYsImV4cCI6MjA4NDIwOTk3Nn0.LMKGjKlUbC5qoY7hqDpaDFQrFWfwKemBTpxjTNp_L8o";

    const TOKEN_KEYS = ["tk_token_v2","tk_token_v1","tk_token"];
    const TOKEN_COOKIES = ["tk_token_v2","tk_token_v1","tk_token"];
    const ME_KEY = "tk_me_v2";
    const DRAFT_KEY_PREFIX = "tk_code_draft_v2:";

    const FILE_ID_RE = /^[a-z]{5}$/;
    const VOID_TAGS = new Set(["area","base","br","col","embed","hr","img","input","link","meta","param","source","track","wbr"]);

    const DEFAULT_START = "<!DOCTYPE html>\n";

    const el = {
      btnExit: document.getElementById("btnExit"),
      btnRevert: document.getElementById("btnRevert"),
      btnDownload: document.getElementById("btnDownload"),
      btnSave: document.getElementById("btnSave"),
      btnClearAll: document.getElementById("btnClearAll"),
      btnFormat: document.getElementById("btnFormat"),

      filePath: document.getElementById("filePath"),

      findInput: document.getElementById("findInput"),
      btnFind: document.getElementById("btnFind"),
      btnFindNext: document.getElementById("btnFindNext"),

      codePane: document.getElementById("codePane"),
      code: document.getElementById("code"),
      codeHl: document.getElementById("codeHl"),
      gutter: document.getElementById("gutter"),
      preview: document.getElementById("preview"),
      errorBar: document.getElementById("errorBar"),
      toast: document.getElementById("toast"),
      measure: document.getElementById("measure"),
    };

    const STATE = {
      fileId: "",
      meta: null,
      remote: "",
      content: "",
      lineStartRow: [],
      errLines: new Set(),
      saving: false,

      lastFind: "",
      findMatches: [],
      findIndex: 0,

      typing: false,
      fastRaf: null,
      heavyTimer: null,
      draftTimer: null,
      resizeTimer: null,
      fastLastLines: 0,
      fastLastWidth: 0,
    };

    const PERF = {
      heavyDelay: 260,
      draftDelay: 900,
      resizeDelay: 90,
    };

    function toast(msg){
      el.toast.textContent = String(msg || "");
      el.toast.classList.add("show");
      setTimeout(() => el.toast.classList.remove("show"), 1200);
    }

    function cookieDomainHint(){
      const host = String(location.hostname || "").trim();
      if(!host || host === "localhost" || host.endsWith(".localhost")) return "";
      if(/^\d+\.\d+\.\d+\.\d+$/.test(host)) return "";
      const parts = host.split(".").filter(Boolean);
      if(parts.length < 2) return "";
      return "." + parts.slice(-2).join(".");
    }

    function setCookie(name, value){
      const v = encodeURIComponent(String(value || ""));
      const maxAge = 60 * 60 * 24 * 365 * 20;
      const base = cookieDomainHint();
      const common = `${name}=${v}; Max-Age=${maxAge}; Path=/; SameSite=Lax`;
      document.cookie = common;
      if(base && base !== location.hostname) document.cookie = `${common}; Domain=${base}`;
    }

    function getCookie(name){
      const cs = document.cookie ? document.cookie.split(";") : [];
      let found = "";
      for(const raw of cs){
        const s = raw.trim();
        if(!s) continue;
        const eq = s.indexOf("=");
        const k = (eq >= 0 ? s.slice(0, eq) : s).trim();
        if(k === name) found = (eq >= 0 ? s.slice(eq + 1) : "");
      }
      try{ return found ? decodeURIComponent(found) : ""; }catch{ return found || ""; }
    }

    function getToken(){
      let t = "";
      for(const k of TOKEN_KEYS){
        try{ t = (localStorage.getItem(k) || "").trim(); if(t) break; }catch{}
      }
      if(!t){
        for(const k of TOKEN_KEYS){
          try{ t = (sessionStorage.getItem(k) || "").trim(); if(t) break; }catch{}
        }
      }
      if(!t){
        for(const c of TOKEN_COOKIES){
          t = (getCookie(c) || "").trim();
          if(t) break;
        }
      }
      try{
        const u = new URL(location.href);
        if(!t){
          const q = (u.searchParams.get("tk") || u.searchParams.get("token") || "").trim();
          if(q) t = q;
        }
        if(!t && u.hash){
          const hs = u.hash.replace(/^#/,"");
          const p = new URLSearchParams(hs);
          const q2 = (p.get("tk") || p.get("token") || "").trim();
          if(q2) t = q2;
        }
      }catch{}
      if(t){
        for(const k of TOKEN_KEYS){
          try{ localStorage.setItem(k, t); }catch{}
          try{ sessionStorage.setItem(k, t); }catch{}
        }
        for(const c of TOKEN_COOKIES){
          try{ setCookie(c, t); }catch{}
        }
      }
      return t;
    }

    function getMeCache(){
      try{
        const raw = localStorage.getItem(ME_KEY);
        if(!raw) return null;
        const obj = JSON.parse(raw);
        if(obj && obj.username) return obj;
      }catch{}
      return null;
    }

    function setMeCache(me){
      try{
        if(!me) localStorage.removeItem(ME_KEY);
        else localStorage.setItem(ME_KEY, JSON.stringify(me));
      }catch{}
    }

    function firstObj(x){
      if(Array.isArray(x)) return x[0] || null;
      if(x && typeof x === "object") return x;
      return null;
    }

    function pickToken(out){
      const o = firstObj(out) || {};
      return (o.token || o.session_token || o.sessionToken || o.access_token || o.accessToken || o.app_token || o.appToken || o.tk || o.jwt || o.bearer || "");
    }

    function pickMe(out){
      const o = firstObj(out) || {};
      let me = o.me || o.user || o.profile || o.data || null;
      if(Array.isArray(me)) me = me[0] || null;
      if(me && typeof me === "object"){
        return { username: me.username || me.name || me.user || me.handle || "", role: me.role || me.user_role || me.userRole || "user" };
      }
      if(o.username){
        return { username: o.username, role: o.role || "user" };
      }
      return null;
    }

    function asOk(out){
      const o = firstObj(out) || {};
      if(o && typeof o.ok === "boolean") return o.ok;
      if(!!pickToken(o)) return true;
      if(!!pickMe(o)) return true;
      return false;
    }

    function sbHeaders(){
      return {
        "apikey": SUPABASE_ANON_KEY,
        "Authorization": "Bearer " + SUPABASE_ANON_KEY,
        "Content-Type": "application/json",
        "Accept": "application/json"
      };
    }

    async function rpc(fn, args){
      const res = await fetch(`${SUPABASE_URL}/rest/v1/rpc/${fn}`, {
        method: "POST",
        headers: sbHeaders(),
        body: JSON.stringify(args || {})
      });
      const txt = await res.text();
      let data = null;
      try{ data = txt ? JSON.parse(txt) : null; }catch{}
      if(!res.ok){
        const msg = (data && (data.message || data.error || data.hint)) ? (data.message || data.error || data.hint) : txt;
        throw new Error(msg || ("RPC failed: " + fn));
      }
      return data;
    }

    async function rpcTry(fns, argsList){
      let lastErr = null;
      const fList = Array.isArray(fns) ? fns : [String(fns || "")].filter(Boolean);
      const aList = (Array.isArray(argsList) && argsList.length) ? argsList : [{}];
      for(const fn of fList){
        for(const args of aList){
          try{ return await rpc(fn, args || {}); }
          catch(e){ lastErr = e; }
        }
      }
      throw (lastErr || new Error("RPC failed"));
    }

    const API = {
      me: async (token) => {
        const t = String(token || "").trim();
        const out = await rpcTry(
          ["api_me","me","app_me","api_whoami","api_profile","whoami"],
          [{p_token:t},{token:t},{p_session:t},{session:t},{session_token:t},{p_session_token:t}]
        );
        return { ok: asOk(out), me: pickMe(out), token: pickToken(out) || "" };
      }
    };

    const CODEAPI = {
      getFile: async (token, codeId) => {
        const t = String(token || "").trim();
        const id = String(codeId || "").trim();
        return await rpcTry(
          ["api_code_get_file","code_get_file","api_code_get"],
          [{p_token:t,p_code_id:id},{token:t,code_id:id},{p_session_token:t,p_code_id:id}]
        );
      },
      saveFile: async (token, codeId, content) => {
        const t = String(token || "").trim();
        const id = String(codeId || "").trim();
        return await rpcTry(
          ["api_code_save_file","code_save_file","api_code_save"],
          [{p_token:t,p_code_id:id,p_content:content},{token:t,code_id:id,content},{p_session_token:t,p_code_id:id,p_content:content}]
        );
      }
    };

    function getFileIdFromUrl(){
      try{
        const u = new URL(location.href);
        const raw = (u.searchParams.get("f") || u.searchParams.get("file") || "").trim().toLowerCase();
        return FILE_ID_RE.test(raw) ? raw : null;
      }catch{
        return null;
      }
    }

    function draftKey(fileId){ return DRAFT_KEY_PREFIX + String(fileId || ""); }

    function loadDraft(fileId){
      try{
        const raw = localStorage.getItem(draftKey(fileId));
        if(!raw) return null;
        const o = JSON.parse(raw);
        if(!o || typeof o.content !== "string") return null;
        return o;
      }catch{ return null; }
    }

    function saveDraft(fileId, content){
      try{
        localStorage.setItem(draftKey(fileId), JSON.stringify({ content: String(content || ""), ts: Date.now() }));
      }catch{}
    }

    function clearDraft(fileId){
      try{ localStorage.removeItem(draftKey(fileId)); }catch{}
    }

    function lintHtmlAccurate(code){
      const s = String(code || "");
      const stack = [];
      const errLines = new Set();

      let line = 1;
      let lastIdx = 0;

      const re = /<!--[\s\S]*?-->|<\s*(\/)?\s*([a-zA-Z][\w:-]*)([^>]*)>/g;
      let m;

      while((m = re.exec(s))){
        const idx = m.index;
        const seg = s.slice(lastIdx, idx);
        const nl = seg.match(/\n/g);
        if(nl) line += nl.length;
        lastIdx = idx;

        const full = m[0] || "";
        if(full.startsWith("<!--")){
          const nl2 = full.match(/\n/g);
          if(nl2) line += nl2.length;
          lastIdx = idx + full.length;
          continue;
        }

        const closing = !!m[1];
        const tag = (m[2] || "").toLowerCase();
        const rest = (m[3] || "");
        const selfClose = /\/\s*$/.test(rest) || VOID_TAGS.has(tag);

        if(selfClose){
          const nl3 = full.match(/\n/g);
          if(nl3) line += nl3.length;
          lastIdx = idx + full.length;
          continue;
        }

        if(!closing){
          stack.push({ tag, line });
        }else{
          if(stack.length === 0){
            errLines.add(line);
          }else{
            const top = stack[stack.length - 1];
            if(top.tag !== tag){
              errLines.add(line);
              errLines.add(top.line);
              let found = -1;
              for(let k = stack.length - 1; k >= 0; k--){
                if(stack[k].tag === tag){ found = k; break; }
              }
              if(found >= 0) stack.splice(found, 1);
              else stack.pop();
            }else{
              stack.pop();
            }
          }
        }

        const nl4 = full.match(/\n/g);
        if(nl4) line += nl4.length;
        lastIdx = idx + full.length;
      }

      if(lastIdx < s.length){
        const nl = s.slice(lastIdx).match(/\n/g);
        if(nl) line += nl.length;
      }

      if(stack.length){
        for(const x of stack) errLines.add(x.line);
      }

      return { ok: errLines.size === 0, errLines };
    }

    function escHtml(s){
      return String(s || "")
        .replace(/&/g,"&amp;")
        .replace(/</g,"&lt;")
        .replace(/>/g,"&gt;");
    }

    function highlightTagEsc(m){
      const mm = m.match(/^(&lt;\/?)([a-zA-Z][\w:-]*)([\s\S]*?)(&gt;)$/);
      if(!mm) return `<span class="tok-tag">${m}</span>`;

      const open = mm[1];
      const name = mm[2];
      const inner = mm[3] || "";
      const close = mm[4];

      let out = "";
      out += `<span class="tok-punc">${open}</span>`;
      out += `<span class="tok-tag">${name}</span>`;

      let i = 0;
      while(i < inner.length){
        const ch = inner[i];

        if(/\s/.test(ch)){
          let j = i + 1;
          while(j < inner.length && /\s/.test(inner[j])) j++;
          out += inner.slice(i, j);
          i = j;
          continue;
        }

        if(ch === "/"){
          out += `<span class="tok-op">/</span>`;
          i++;
          continue;
        }

        let j = i;
        while(j < inner.length && !/\s/.test(inner[j]) && inner[j] !== "=" && inner[j] !== "/") j++;
        const attr = inner.slice(i, j);
        i = j;

        let k = i;
        while(k < inner.length && /\s/.test(inner[k])) k++;

        if(inner[k] === "="){
          out += `<span class="tok-attr">${attr}</span>`;
          out += `<span class="tok-op">=</span>`;
          k++;
          while(k < inner.length && /\s/.test(inner[k])) k++;

          if(inner[k] === '"' || inner[k] === "'"){
            const q = inner[k];
            let p = k + 1;
            while(p < inner.length && inner[p] !== q) p++;
            const val = inner.slice(k, Math.min(p + 1, inner.length));
            out += `<span class="tok-str">${val}</span>`;
            i = Math.min(p + 1, inner.length);
          }else{
            let p = k;
            while(p < inner.length && !/\s/.test(inner[p]) && inner[p] !== "/") p++;
            const val = inner.slice(k, p);
            out += `<span class="tok-str">${val}</span>`;
            i = p;
          }
        }else{
          out += `<span class="tok-attr">${attr}</span>`;
          i = k;
        }
      }

      out += `<span class="tok-punc">${close}</span>`;
      return out;
    }

    function highlightHtml(raw){
      const s0 = escHtml(raw || "");

      const parts = [];
      const re = /&lt;!--[\s\S]*?--&gt;|&lt;!DOCTYPE[\s\S]*?&gt;|&lt;\/?[a-zA-Z][\w:-]*[\s\S]*?&gt;/gi;

      let last = 0;
      let m;
      while((m = re.exec(s0))){
        const idx = m.index;
        if(idx > last){
          const txt = s0.slice(last, idx);
          parts.push(`<span class="tok-txt">${txt || " "}</span>`);
        }

        const tok = m[0] || "";
        if(tok.startsWith("&lt;!--")){
          parts.push(`<span class="tok-com">${tok}</span>`);
        }else if(/^&lt;!DOCTYPE/i.test(tok)){
          parts.push(`<span class="tok-doctype">${tok}</span>`);
        }else{
          parts.push(highlightTagEsc(tok));
        }

        last = idx + tok.length;
      }

      if(last < s0.length){
        const tail = s0.slice(last);
        parts.push(`<span class="tok-txt">${tail || " "}</span>`);
      }

      let out = parts.join("");
      if(!out) out = " ";
      if(out.endsWith("\n")) out += " ";
      return out;
    }

    function clearFindMarks(){
      const root = el.codeHl;
      const marks = root.querySelectorAll(".tok-find");
      for(const mk of marks){
        const parent = mk.parentNode;
        if(!parent) continue;
        parent.replaceChild(document.createTextNode(mk.textContent || ""), mk);
        parent.normalize();
      }
    }

    function buildFindMatches(text, q){
      const t = String(text || "");
      const needle = String(q || "");
      const out = [];
      if(!needle) return out;

      let i = 0;
      while(true){
        const idx = t.indexOf(needle, i);
        if(idx < 0) break;
        out.push({ start: idx, end: idx + needle.length });
        i = idx + Math.max(1, needle.length);
      }
      return out;
    }

    function applyFindMarksDom(q){
      clearFindMarks();
      const needle = String(q || "");
      if(!needle) return [];

      const root = el.codeHl;
      const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, null);
      const spans = [];

      let node;
      while((node = walker.nextNode())){
        const txt = node.nodeValue || "";
        if(!txt) continue;
        let idx = txt.indexOf(needle);
        if(idx < 0) continue;

        const frag = document.createDocumentFragment();
        let last = 0;

        while(idx >= 0){
          if(idx > last) frag.appendChild(document.createTextNode(txt.slice(last, idx)));

          const sp = document.createElement("span");
          sp.className = "tok-find";
          sp.textContent = needle;
          frag.appendChild(sp);
          spans.push(sp);

          last = idx + needle.length;
          idx = txt.indexOf(needle, last);
        }

        if(last < txt.length) frag.appendChild(document.createTextNode(txt.slice(last)));

        const parent = node.parentNode;
        if(parent) parent.replaceChild(frag, node);
      }

      return spans;
    }

    function setActiveFind(index){
      const spans = el.codeHl.querySelectorAll(".tok-find");
      for(const s of spans) s.classList.remove("active");
      const i = Math.max(0, Math.min(index, spans.length - 1));
      if(spans[i]) spans[i].classList.add("active");
    }

    function updatePreview(){
      el.preview.srcdoc = String(el.code.value || "");
    }

    function computeWrapCounts(lines, textWidthPx, lineHeightPx){
      el.measure.style.width = Math.max(20, textWidthPx) + "px";
      const counts = new Array(lines.length);
      for(let i=0;i<lines.length;i++){
        const s = lines[i];
        el.measure.textContent = (s.length ? s : " ");
        const h = el.measure.scrollHeight;
        const wraps = Math.max(1, Math.ceil(h / lineHeightPx));
        counts[i] = wraps;
      }
      return counts;
    }

    function rebuildGutterAndHeight(){
      const ta = el.code;

      const cs = getComputedStyle(ta);
      const padL = parseFloat(cs.paddingLeft) || 0;
      const padR = parseFloat(cs.paddingRight) || 0;
      const lh = parseFloat(cs.lineHeight) || 22;

      const textWidth = Math.max(20, ta.clientWidth - padL - padR);

      const text = ta.value || "";
      const lines = text.split("\n");
      const wrapCounts = computeWrapCounts(lines, textWidth, lh);

      let out = [];
      let rowIndex = 0;
      STATE.lineStartRow = new Array(Math.max(lines.length, 10));

      const needMin = Math.max(10, lines.length);

      for(let i=0;i<needMin;i++){
        const ln = i + 1;
        const wraps = (i < wrapCounts.length) ? wrapCounts[i] : 1;

        STATE.lineStartRow[i] = rowIndex;

        for(let w=0; w<wraps; w++){
          const first = (w === 0);
          const isErr = first && STATE.errLines.has(ln);
          const cls = "gline" + (isErr ? " err" : "");
          const label = first ? String(ln) : "";
          out.push(`<div class="${cls}" data-row="${rowIndex}" data-line="${ln}">${label}</div>`);
          rowIndex++;
        }
      }

      el.gutter.innerHTML = out.join("");

      ta.style.height = "auto";
      ta.style.height = ta.scrollHeight + "px";
      el.codeHl.style.height = ta.style.height;
    }

    function fastSyncHeightAndGutter(){
      const ta = el.code;

      ta.style.height = "auto";
      ta.style.height = ta.scrollHeight + "px";
      el.codeHl.style.height = ta.style.height;

      const lineCount = (ta.value || "").split("\n").length;
      const w = ta.clientWidth;

      if(lineCount === STATE.fastLastLines && w === STATE.fastLastWidth) return;
      STATE.fastLastLines = lineCount;
      STATE.fastLastWidth = w;

      const needMin = Math.max(10, lineCount);
      const out = new Array(needMin);
      STATE.lineStartRow = new Array(needMin);

      for(let i=0;i<needMin;i++){
        const ln = i + 1;
        STATE.lineStartRow[i] = i;
        const isErr = STATE.errLines.has(ln);
        const cls = "gline" + (isErr ? " err" : "");
        out[i] = `<div class="${cls}" data-row="${i}" data-line="${ln}">${ln}</div>`;
      }

      el.gutter.innerHTML = out.join("");
    }

    function renderErrorBar(){
      const bar = el.errorBar;
      const errArr = [...STATE.errLines].sort((a,b)=>a-b);

      if(errArr.length === 0){
        bar.classList.remove("show");
        bar.textContent = "";
        return;
      }

      const first = errArr[0];
      bar.textContent = `Phát hiện ${errArr.length} lỗi ở dòng ${first}`;
      bar.classList.add("show");
    }

    function scrollToLine(lineNo){
      const idx = Math.max(1, Number(lineNo) || 1);
      const startRow = STATE.lineStartRow[idx - 1] ?? 0;
      const target = el.gutter.querySelector(`.gline[data-row="${startRow}"]`);
      if(target) target.scrollIntoView({ block:"center", behavior:"smooth" });

      const text = el.code.value || "";
      let pos = 0;
      if(idx > 1){
        let p = 0;
        for(let i=1;i<idx;i++){
          const n = text.indexOf("\n", p);
          if(n < 0){ p = text.length; break; }
          p = n + 1;
        }
        pos = p;
      }
      try{
        el.code.focus();
        el.code.setSelectionRange(pos, pos);
      }catch{}
    }

    function renderHighlight(){
      el.codeHl.innerHTML = highlightHtml(el.code.value || "");
      const q = String(el.findInput.value || "").trim();
      if(q){
        const spans = applyFindMarksDom(q);
        setActiveFind(STATE.findIndex || 0);
        const showNext = spans.length > 1;
        el.btnFindNext.style.display = showNext ? "" : "none";
        el.btnFindNext.disabled = spans.length <= 1;
      }else{
        el.btnFindNext.style.display = "none";
        el.btnFindNext.disabled = true;
      }
    }

    function getLineFromPos(pos){
      const text = el.code.value || "";
      const before = text.slice(0, Math.max(0, pos));
      return before.split("\n").length;
    }

    function selectMatchAt(i){
      if(!STATE.findMatches.length) return;
      const idx = ((i % STATE.findMatches.length) + STATE.findMatches.length) % STATE.findMatches.length;
      STATE.findIndex = idx;

      const m = STATE.findMatches[idx];
      try{
        el.code.focus();
        el.code.setSelectionRange(m.start, m.end);
      }catch{}

      const lineNo = getLineFromPos(m.start);
      scrollToLine(lineNo);

      setActiveFind(idx);
      toast(`${idx + 1}/${STATE.findMatches.length}`);
    }

    function recomputeFind(){
      const q = String(el.findInput.value || "").trim();
      el.btnFind.disabled = !q;

      if(!q){
        STATE.lastFind = "";
        STATE.findMatches = [];
        STATE.findIndex = 0;
        el.btnFindNext.style.display = "none";
        el.btnFindNext.disabled = true;
        renderHighlight();
        return;
      }

      STATE.lastFind = q;
      STATE.findMatches = buildFindMatches(el.code.value || "", q);
      if(STATE.findIndex >= STATE.findMatches.length) STATE.findIndex = 0;

      el.btnFindNext.style.display = (STATE.findMatches.length > 1) ? "" : "none";
      el.btnFindNext.disabled = STATE.findMatches.length <= 1;

      renderHighlight();
    }

    function enterTyping(){
      if(STATE.typing) return;
      STATE.typing = true;
      el.codePane.classList.add("typing");
    }

    function exitTyping(){
      if(!STATE.typing) return;
      STATE.typing = false;
      el.codePane.classList.remove("typing");
    }

    function scheduleDraftSave(){
      if(STATE.draftTimer) clearTimeout(STATE.draftTimer);
      STATE.draftTimer = setTimeout(() => {
        STATE.draftTimer = null;
        if(!STATE.fileId) return;
        saveDraft(STATE.fileId, el.code.value || "");
      }, PERF.draftDelay);
    }

    function scheduleFastSync(){
      if(STATE.fastRaf) return;
      STATE.fastRaf = requestAnimationFrame(() => {
        STATE.fastRaf = null;
        fastSyncHeightAndGutter();
      });
    }

    function runHeavyUpdate(){
      exitTyping();

      const v = el.code.value || "";
      STATE.content = v;

      if(STATE.fileId) saveDraft(STATE.fileId, v);

      const lint = lintHtmlAccurate(v);
      STATE.errLines = lint.errLines;

      renderErrorBar();
      rebuildGutterAndHeight();
      updatePreview();
      updateFormatAvailability();
      recomputeFind();
    }

    function scheduleHeavyUpdate(){
      if(STATE.heavyTimer) clearTimeout(STATE.heavyTimer);
      STATE.heavyTimer = setTimeout(() => {
        STATE.heavyTimer = null;
        runHeavyUpdate();
      }, PERF.heavyDelay);
    }

    function flushHeavyNow(){
      if(STATE.fastRaf){
        cancelAnimationFrame(STATE.fastRaf);
        STATE.fastRaf = null;
      }
      if(STATE.heavyTimer){
        clearTimeout(STATE.heavyTimer);
        STATE.heavyTimer = null;
      }
      if(STATE.draftTimer){
        clearTimeout(STATE.draftTimer);
        STATE.draftTimer = null;
      }
      runHeavyUpdate();
    }

    function onEditorInput(){
      enterTyping();
      scheduleFastSync();
      scheduleDraftSave();
      scheduleHeavyUpdate();
    }

    function doFindFirstOrCurrent(){
      flushHeavyNow();
      const q = String(el.findInput.value || "").trim();
      if(!q){ toast("Chưa nhập từ khoá"); return; }

      const matches = buildFindMatches(el.code.value || "", q);
      STATE.lastFind = q;
      STATE.findMatches = matches;

      if(!matches.length){
        STATE.findIndex = 0;
        el.btnFindNext.style.display = "none";
        el.btnFindNext.disabled = true;
        renderHighlight();
        toast("Không tìm thấy");
        return;
      }

      const cur = Math.max(0, el.code.selectionStart || 0);
      let pick = 0;
      for(let i=0;i<matches.length;i++){
        if(matches[i].start >= cur){ pick = i; break; }
        pick = 0;
      }

      STATE.findIndex = pick;
      renderHighlight();
      selectMatchAt(pick);
    }

    function doFindNext(){
      flushHeavyNow();
      if(!STATE.findMatches.length){
        doFindFirstOrCurrent();
        return;
      }
      const next = (STATE.findIndex + 1) % STATE.findMatches.length;
      renderHighlight();
      selectMatchAt(next);
    }

    async function doSave(){
      if(STATE.saving) return;
      flushHeavyNow();
      STATE.saving = true;
      el.btnSave.disabled = true;

      try{
        const token = getToken();
        if(!token) throw new Error("Chưa đăng nhập");

        const html = el.code.value || "";
        const out = await CODEAPI.saveFile(token, STATE.fileId, html);
        const o = firstObj(out) || out || {};
        if(o.ok !== true) throw new Error(o.error || o.message || "Lưu lỗi");

        STATE.remote = html;
        clearDraft(STATE.fileId);
        toast("Đã lưu");
      }catch(e){
        toast(String(e && e.message ? e.message : "Lưu lỗi"));
      }finally{
        el.btnSave.disabled = false;
        STATE.saving = false;
      }
    }

    async function doRevert(){
      flushHeavyNow();
      const ok = confirm("Quay lại bản đã lưu?");
      if(!ok) return;
      clearDraft(STATE.fileId);
      el.code.value = (STATE.remote && STATE.remote.trim()) ? STATE.remote : DEFAULT_START;
      STATE.content = el.code.value;
      toast("Đã hoàn tác");
      flushHeavyNow();
    }

    function doDownload(){
      const name = (STATE.meta && STATE.meta.name) ? String(STATE.meta.name) : "file.html";
      const blob = new Blob([el.code.value || ""], { type:"text/html;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = name.toLowerCase().endsWith(".html") ? name : (name + ".html");
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(() => URL.revokeObjectURL(url), 500);
      toast("Đang tải");
    }

    function doClearAll(){
      flushHeavyNow();
      const ok = confirm("Xoá tất cả nội dung? (Giữ lại <!DOCTYPE html>)");
      if(!ok) return;
      clearDraft(STATE.fileId);
      el.code.value = DEFAULT_START;
      STATE.content = el.code.value;
      toast("Đã xoá");
      flushHeavyNow();
    }

    function bindShortcuts(){
      document.addEventListener("keydown", (e) => {
        const isMac = /Mac|iPhone|iPad|iPod/i.test(navigator.platform);
        const mod = isMac ? e.metaKey : e.ctrlKey;

        if(mod && (e.key === "s" || e.key === "S")){
          e.preventDefault();
          doSave();
        }
        if(mod && (e.key === "f" || e.key === "F")){
          e.preventDefault();
          el.findInput.focus();
          el.findInput.select?.();
        }
      }, { passive:false });
    }

    function goExit(){
      location.href = "/code";
    }

    function autoIndentOnEnter(e){
      if(e.key !== "Enter") return;
      e.preventDefault();

      const ta = el.code;
      const v = ta.value || "";
      const start = ta.selectionStart || 0;
      const end = ta.selectionEnd || 0;

      const ls = v.lastIndexOf("\n", Math.max(0, start - 1)) + 1;
      const linePrefix = v.slice(ls, start);
      const m = linePrefix.match(/^[\t ]*/);
      const indent = m ? m[0] : "";

      const insert = "\n" + indent;
      try{
        ta.setRangeText(insert, start, end, "end");
      }catch{
        ta.value = v.slice(0, start) + insert + v.slice(end);
        ta.selectionStart = ta.selectionEnd = start + insert.length;
      }

      onEditorInput();
    }

    function tokenizeForFormat(html){
      const s = String(html || "").replace(/\r\n/g, "\n").replace(/\r/g, "\n");
      const re = /<!--[\s\S]*?-->|<!DOCTYPE[\s\S]*?>|<\/?[a-zA-Z][\w:-]*(?:\s[^<>]*?)?>|[^<]+/gi;
      const out = [];
      let m;
      while((m = re.exec(s))){
        out.push(m[0] || "");
      }
      return out;
    }

    function isClosingTag(tok){
      return /^<\/\s*[a-zA-Z]/.test(tok);
    }

    function isDoctype(tok){
      return /^<!DOCTYPE/i.test(tok);
    }

    function isComment(tok){
      return /^<!--/.test(tok);
    }

    function isTag(tok){
      return /^</.test(tok) && />$/.test(tok);
    }

    function getTagName(tok){
      const m = tok.match(/^<\/?\s*([a-zA-Z][\w:-]*)/);
      return (m && m[1]) ? m[1].toLowerCase() : "";
    }

    function isSelfClosing(tok){
      const name = getTagName(tok);
      if(!name) return false;
      if(VOID_TAGS.has(name)) return true;
      return /\/\s*>$/.test(tok);
    }

    function formatHtml(code){
      const raw = String(code || "");
      const toks = tokenizeForFormat(raw);
      const indentUnit = "  ";

      let out = [];
      let indent = 0;

      for(const t0 of toks){
        const t = String(t0 || "");
        if(!t) continue;

        if(isDoctype(t)){
          out.push("<!DOCTYPE html>");
          continue;
        }

        if(isComment(t)){
          const lines = t.replace(/\r\n/g, "\n").replace(/\r/g, "\n").trim().split("\n");
          for(const ln of lines){
            out.push(indentUnit.repeat(Math.max(0, indent)) + ln.trim());
          }
          continue;
        }

        if(isTag(t)){
          if(isClosingTag(t)){
            indent = Math.max(0, indent - 1);
            out.push(indentUnit.repeat(indent) + t.trim());
          }else if(isSelfClosing(t)){
            out.push(indentUnit.repeat(indent) + t.trim());
          }else{
            out.push(indentUnit.repeat(indent) + t.trim());
            indent++;
          }
          continue;
        }

        const txt = t.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
        const lines = txt.split("\n");
        for(const ln of lines){
          const trimmed = ln.trim();
          if(trimmed){
            out.push(indentUnit.repeat(Math.max(0, indent)) + trimmed);
          }
        }
      }

      let formatted = out.join("\n").replace(/[ \t]+\n/g, "\n").trimEnd();
      if(!formatted) formatted = DEFAULT_START.trimEnd();
      if(!formatted.startsWith("<!DOCTYPE html>")) formatted = "<!DOCTYPE html>\n" + formatted;
      if(!formatted.endsWith("\n")) formatted += "\n";
      return formatted;
    }

    function updateFormatAvailability(){
      const cur = String(el.code.value || "");
      const fmt = formatHtml(cur);
      const can = fmt !== cur;
      el.btnFormat.disabled = !can;
    }

    function doFormat(){
      flushHeavyNow();
      if(el.btnFormat.disabled) return;
      const cur = String(el.code.value || "");
      const fmt = formatHtml(cur);
      if(fmt === cur){
        updateFormatAvailability();
        return;
      }
      el.code.value = fmt;
      toast("Đã căn chỉnh");
      flushHeavyNow();
    }

    async function boot(){
      const fileId = getFileIdFromUrl();
      if(!fileId){
        toast("Thiếu hoặc sai f (5 chữ).");
        location.replace("/code");
        return;
      }
      STATE.fileId = fileId;

      const token = getToken();
      if(!token){
        location.replace("/code");
        return;
      }

      const cachedMe = getMeCache();
      if(!cachedMe || !cachedMe.username){
        try{
          const meOut = await API.me(token);
          if(meOut && meOut.ok && meOut.me && meOut.me.username){
            setMeCache(meOut.me);
          }
        }catch{}
      }

      try{
        const raw = await CODEAPI.getFile(token, fileId);
        const o = firstObj(raw) || raw || {};
        if(o.ok !== true) throw new Error(o.error || o.message || "Không mở được file");

        STATE.meta = o.node || o.file || o.meta || {};
        STATE.remote = String(o.content || "");

        const name = String((STATE.meta && STATE.meta.name) ? STATE.meta.name : ("file-" + fileId + ".html"));
        const path = String(o.full_path || o.path || name);

        el.filePath.textContent = path || "—";

        const draft = loadDraft(fileId);
        if(draft && typeof draft.content === "string"){
          el.code.value = draft.content;
        }else{
          const r = (STATE.remote || "").trim();
          el.code.value = r ? STATE.remote : DEFAULT_START;
        }

        const lint = lintHtmlAccurate(el.code.value || "");
        STATE.errLines = lint.errLines;

        renderErrorBar();
        rebuildGutterAndHeight();
        updatePreview();
        updateFormatAvailability();
        recomputeFind();

        try{ el.code.focus(); }catch{}

      }catch(e){
        toast(String(e && e.message ? e.message : "Không mở được file"));
        location.replace("/code");
        return;
      }

      el.btnExit.addEventListener("click", goExit);
      el.btnSave.addEventListener("click", doSave);
      el.btnRevert.addEventListener("click", doRevert);
      el.btnDownload.addEventListener("click", doDownload);
      el.btnClearAll.addEventListener("click", doClearAll);
      el.btnFormat.addEventListener("click", doFormat);

      el.findInput.addEventListener("input", () => {
        STATE.findIndex = 0;
        recomputeFind();
      }, { passive:true });

      el.btnFind.addEventListener("click", doFindFirstOrCurrent);
      el.btnFindNext.addEventListener("click", doFindNext);

      el.findInput.addEventListener("keydown", (e) => {
        if(e.key === "Enter"){
          e.preventDefault();
          doFindFirstOrCurrent();
        }
      });

      el.errorBar.addEventListener("click", () => {
        flushHeavyNow();
        const arr = [...STATE.errLines].sort((a,b)=>a-b);
        if(arr.length) scrollToLine(arr[0]);
      });

      el.code.addEventListener("input", onEditorInput, { passive:true });
      el.code.addEventListener("keydown", autoIndentOnEnter, { passive:false });

      bindShortcuts();

      window.addEventListener("resize", () => {
        if(STATE.resizeTimer) clearTimeout(STATE.resizeTimer);
        STATE.resizeTimer = setTimeout(() => {
          STATE.resizeTimer = null;
          if(STATE.typing){
            scheduleFastSync();
            scheduleHeavyUpdate();
          }else{
            rebuildGutterAndHeight();
            recomputeFind();
          }
        }, PERF.resizeDelay);
      }, { passive:true });

      window.addEventListener("beforeunload", () => {
        try{
          if(STATE.fileId) saveDraft(STATE.fileId, el.code.value || "");
        }catch{}
      }, { passive:true });
    }

    boot();
  </script>
</body>
</html>

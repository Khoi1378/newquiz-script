<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Vocabulary Check</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@500;700;800&display=swap" rel="stylesheet">

  <style>
    :root {
      --bg1: #ffecd2; --bg2: #fcb69f;
      --card: #fff; --text: #1f2937; --muted: #6b7280;
      --primary: #7c3aed; --ok: #16a34a; --bad: #dc2626;
      --border: #e5e7eb; --soft: #f8fafc;
      --shadow: 0 14px 40px rgba(0,0,0,.10);
      --radius: 18px;
      --gold: #f59e0b; --silver: #94a3b8; --bronze: #d97706;
      --admin: #2563eb;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: "Montserrat", system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: var(--text);
      background: radial-gradient(1200px 600px at 20% 10%, #fff 0%, rgba(255,255,255,0) 55%),
                  linear-gradient(120deg, var(--bg1) 0%, var(--bg2) 100%);
      overflow: hidden;
    }

    /* gi·∫£m delay c·∫£m gi√°c tr√™n mobile */
    .btn, .pinKey, .cmtBtn, .btn-x {
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
    }

    #shell { height: 100vh; overflow: auto; -webkit-overflow-scrolling: touch; padding: 12px 0 110px; }
    .wrap { max-width: 980px; margin: 0 auto; padding: 0 14px; }

    /* username corner (nh·∫°t g√≥c tr√°i tr√™n) */
    .userCorner {
      position: fixed;
      top: 10px;
      left: 12px;
      z-index: 10010; /* th·∫•p h∆°n modal */
      display: none;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,.55);
      border: 1px solid rgba(229,231,235,.65);
      backdrop-filter: blur(6px);
      box-shadow: 0 10px 22px rgba(0,0,0,.06);
      user-select: none;
      max-width: calc(100vw - 24px);
      cursor: pointer;
    }
    .userCorner .name {
      font-weight: 950;
      font-size: .88rem;
      color: rgba(31,41,55,.55);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 58vw;
    }
    .userCorner .adminBadge {
      padding: 4px 8px;
      border-radius: 999px;
      font-weight: 950;
      font-size: .78rem;
      background: rgba(37,99,235,.12);
      border: 1px solid rgba(37,99,235,.35);
      color: var(--admin);
      white-space: nowrap;
    }

    .actionbar {
      position: sticky; top: 10px; z-index: 9999;
      display: flex; justify-content: flex-end; gap: 10px; padding: 0 14px;
      flex-wrap: wrap;
    }
    .btn {
      border: 0; cursor: pointer;
      border-radius: 999px; padding: 10px 14px;
      font-weight: 900; font-size: .9rem;
      transition: transform .16s ease, filter .16s ease;
      display: inline-flex; align-items: center; gap: 8px;
      user-select: none; white-space: nowrap;
      box-shadow: 0 12px 24px rgba(0,0,0,.12);
      background: #fff; color: #111827; border: 1px solid #e5e7eb;
    }
    .btn:hover { transform: translateY(-1px); filter: brightness(.98); }
    .btn:active { transform: translateY(0px); }
    .btn-reset { background: #111827; color: #fff; border: 0; }
    .btn-primary {
      background: linear-gradient(135deg, #7c3aed, #fb7185);
      color: #fff; border: 0;
      box-shadow: 0 12px 24px rgba(124,58,237,.18);
    }

    /* CHECK: nh·ªè, ch·ªØ "Check" */
    .btn-check {
      border-radius: 12px;
      padding: 9px 10px;
      font-size: .86rem;
      font-weight: 950;
      box-shadow: 0 10px 20px rgba(124,58,237,.14);
      width: auto;
      min-width: 86px;
      justify-content: center;
    }
    .btn-check[disabled] { opacity: .65; cursor: not-allowed; }

    .topbar {
      margin-top: 10px;
      background: rgba(255,255,255,.86);
      border: 1px solid rgba(229,231,235,.9);
      border-radius: 18px;
      box-shadow: 0 10px 30px rgba(0,0,0,.06);
      padding: 14px;
      display: flex; gap: 12px; align-items: center; justify-content: space-between; flex-wrap: wrap;
    }
    .titlebox { display: flex; gap: 10px; align-items: center; flex: 1 1 360px; min-width: 240px; }
    .logo {
      width: 42px; height: 42px; border-radius: 16px;
      background: linear-gradient(135deg, #a78bfa, #fb7185);
      display: flex; align-items: center; justify-content: center;
      color: #fff; font-weight: 900;
      box-shadow: 0 10px 22px rgba(124,58,237,.18);
      user-select: none;
    }
    .titles h1 { font-size: 1.02rem; margin: 0; font-weight: 800; }
    .titles .tiny { margin-top: 3px; font-size: .86rem; color: var(--muted); font-weight: 650; }

    .stats { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    .pill {
      background: #f3f4f6; border: 1px solid #e5e7eb;
      border-radius: 999px; padding: 8px 12px;
      font-weight: 800; font-size: .9rem; color: #374151; white-space: nowrap;
    }
    .pill strong { color: var(--primary); }
    .progressline {
      height: 10px; border-radius: 999px; background: #f3f4f6; overflow: hidden;
      border: 1px solid #e5e7eb; width: 100%; max-width: 360px;
    }
    .progressfill {
      height: 100%; width: 0%;
      background: linear-gradient(90deg, #22c55e, #a78bfa);
      transition: width .25s ease;
    }

    .content { padding: 12px 0 0; }
    .card {
      background: var(--card);
      border: 2px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      padding: 14px; margin: 12px 0;
    }
    .row1 { display: flex; align-items: flex-start; justify-content: space-between; gap: 10px; flex-wrap: wrap; }
    .vi { margin: 0; font-weight: 900; font-size: 1.04rem; line-height: 1.25; }
    .meta { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    .idx {
      font-size: .78rem; font-weight: 900;
      padding: 6px 10px; border-radius: 999px;
      background: #eff6ff; color: #1d4ed8; border: 1px solid #dbeafe;
      white-space: nowrap;
    }
    .muted { color: var(--muted); font-weight: 650; }

    .input {
      width: 100%;
      border-radius: 14px; border: 2px solid #e5e7eb;
      padding: 11px 12px; font-size: .95rem; font-weight: 700;
      outline: none; background: var(--soft);
      transition: border-color .15s ease, box-shadow .15s ease;
    }
    .input:focus {
      border-color: rgba(124,58,237,.55);
      box-shadow: 0 0 0 5px rgba(124,58,237,.10);
      background: #fff;
    }
    .input[disabled] { background: #f3f4f6; color: #111827; }

    /* row input + check */
    .qaRow{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap: wrap;
    }
    .qaRow .input{ flex: 1 1 260px; }

    .resultRow{
      display:grid;
      grid-template-columns: 140px 1fr;
      gap:10px;
      align-items:center;
      margin-top:10px;
      padding: 10px 12px;
      border-radius: 16px;
      border: 1px dashed #e5e7eb;
      background: #fff;
      font-weight: 800;
      line-height: 1.35;
    }
    .oktxt { color: var(--ok); font-weight: 1000; }
    .badtxt { color: var(--bad); font-weight: 1000; }

    .table {
      width: 100%;
      border-collapse: separate;
      border-spacing: 0;
      overflow: hidden;
      border-radius: 16px;
      border: 1px solid #e5e7eb;
      background: #fff;
      table-layout: fixed; /* quan tr·ªçng: kh√¥ng tr√†n ngang */
    }
    .table th, .table td {
      padding: 10px 10px;
      border-bottom: 1px solid #e5e7eb;
      text-align: left;
      font-weight: 750;
      font-size: .92rem;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .table th { background: #f8fafc; font-weight: 900; }
    .table tr:last-child td { border-bottom: 0; }

    .rankpill {
      display: inline-flex; align-items: center; gap: 8px;
      border-radius: 999px; padding: 6px 10px;
      font-weight: 950; font-size: .86rem;
      border: 1px solid #e5e7eb;
      background: #fff;
      white-space: nowrap;
    }
    .medal {
      width: 22px; height: 22px; border-radius: 999px;
      display: inline-flex; align-items: center; justify-content: center;
      font-size: .9rem;
      color: #111827;
      border: 1px solid rgba(0,0,0,.08);
      box-shadow: 0 10px 22px rgba(0,0,0,.10);
      flex: 0 0 auto;
    }
    .m1 { background: linear-gradient(135deg, #fde68a, #f59e0b); }
    .m2 { background: linear-gradient(135deg, #e2e8f0, #94a3b8); }
    .m3 { background: linear-gradient(135deg, #fdba74, #d97706); }

    .toprow1 td { background: rgba(245,158,11,.10); }
    .toprow2 td { background: rgba(148,163,184,.12); }
    .toprow3 td { background: rgba(217,119,6,.10); }

    .meRow td {
      background: rgba(124,58,237,.12) !important;
      border-top: 1px solid rgba(124,58,237,.25);
      border-bottom: 1px solid rgba(124,58,237,.25);
    }
    .meRow td:first-child { border-left: 6px solid rgba(124,58,237,.55); }
    .meName { font-weight: 1000; letter-spacing: .01em; }
    .meBadge {
      margin-left: 8px;
      padding: 4px 8px;
      border-radius: 999px;
      font-weight: 900;
      font-size: .78rem;
      background: rgba(124,58,237,.14);
      border: 1px solid rgba(124,58,237,.35);
      color: #4c1d95;
      white-space: nowrap;
    }
    .adminBadgeInline{
      margin-left: 8px;
      padding: 4px 8px;
      border-radius: 999px;
      font-weight: 950;
      font-size: .78rem;
      background: rgba(37,99,235,.12);
      border: 1px solid rgba(37,99,235,.35);
      color: var(--admin);
      white-space: nowrap;
    }

    /* leaderboard: c·ªôt t√™n ellipsis */
    .lbName{
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      display:block;
      width: 100%;
    }

    /* ===== MODAL STACK FIX (quan tr·ªçng) ===== */
    .modal-backdrop {
      position: fixed; inset: 0; background: rgba(0,0,0,.35);
      display: none; align-items: center; justify-content: center;
      padding: 16px;
      z-index: 20000; /* cao h∆°n h·∫øt ph·∫ßn UI */
    }
    .modal-backdrop.show { display: flex; }
    #modalBackdrop { z-index: 20010; }    /* reset confirm */
    #registerBackdrop { z-index: 20015; } /* ‚úÖ register confirm */
    #wrongBackdrop { z-index: 20020; }    /* wrong popup */
    #profileBackdrop { z-index: 20030; }  /* profile */
    #pinBackdrop { z-index: 20040; }      /* PIN modal lu√¥n ·ªü tr√™n c√πng */

    .modal {
      width: 100%; max-width: 620px;
      background: #fff;
      border-radius: 18px;
      border: 1px solid #e5e7eb;
      box-shadow: 0 20px 60px rgba(0,0,0,.18);
      padding: 14px;
      max-height: 82vh;
      overflow: auto;
      -webkit-overflow-scrolling: touch;
    }
    .modal h3 { margin: 4px 0 6px; font-size: 1.02rem; }
    .modal p { margin: 0 0 12px; color: var(--muted); font-weight: 650; font-size: .92rem; line-height: 1.35; }
    .modal-actions { display: flex; gap: 10px; justify-content: flex-end; flex-wrap: wrap; }
    .btn-ghost { background: #fff; color: #111827; border: 1px solid #e5e7eb; box-shadow: none; }
    .btn-danger { background: var(--bad); color: #fff; border: 0; }

    .xclose { position: sticky; top: 0; display: flex; justify-content: flex-end; z-index: 2; margin-bottom: 4px; }
    .btn-x {
      width: 56px; height: 56px;
      border-radius: 16px;
      border: 1px solid #e5e7eb;
      background: #fff;
      cursor: pointer;
      font-weight: 1000;
      font-size: 1.8rem;
      line-height: 1;
      box-shadow: 0 12px 24px rgba(0,0,0,.10);
    }
    .btn-x:hover { filter: brightness(.98); transform: translateY(-1px); }
    .btn-x:active { transform: translateY(0px); }

    .toast {
      position: fixed; left: 50%; bottom: 18px; transform: translateX(-50%);
      background: rgba(17,24,39,.92); color: #fff;
      padding: 10px 12px; border-radius: 14px;
      font-weight: 800; font-size: .9rem;
      opacity: 0; pointer-events: none;
      transition: opacity .18s ease, transform .18s ease;
      max-width: calc(100% - 28px);
      z-index: 20050;
      text-align: center;
    }
    .toast.show { opacity: 1; transform: translateX(-50%) translateY(-4px); }

    /* Discussion button (small, only after done) */
    .fabDiscuss {
      position: fixed;
      right: 14px;
      bottom: 18px;
      z-index: 10010; /* d∆∞·ªõi modal */
      display: none;
    }
    .btn-discuss-mini{
      padding: 9px 12px;
      font-size: .86rem;
    }

    /* Discussion styles */
    .cmtBox { display: grid; gap: 12px; }
    .cmtItem {
      border: 1px solid #e5e7eb;
      border-radius: 16px;
      padding: 12px;
      background: #fff;
    }
    .cmtHead {
      display:flex; justify-content: space-between; gap: 10px; flex-wrap: wrap;
      align-items: center;
      margin-bottom: 8px;
    }
    .cmtAuthor {
      font-weight: 950;
      color: #6b7280; /* username x√°m */
      display:flex; gap: 8px; align-items:center; flex-wrap: wrap;
    }
    .cmtText { color: #111827; font-weight: 750; line-height: 1.35; white-space: pre-wrap; word-break: break-word; }
    .cmtActions {
      display:flex; gap: 8px; flex-wrap: wrap;
      margin-top: 10px;
      justify-content: flex-end; /* d·ªìn sang ph·∫£i */
    }
    .cmtBtn {
      border-radius: 999px;
      padding: 7px 10px;
      font-weight: 900;
      border: 1px solid #e5e7eb;
      background: #fff;
      cursor: pointer;
      font-size: .82rem; /* nh·ªè h∆°n */
    }
    .cmtBtnDanger { background: rgba(220,38,38,.1); border-color: rgba(220,38,38,.25); color: #991b1b; }
    .cmtTime {
      margin-top: 6px;
      text-align: right;
      color: #6b7280;
      font-weight: 800;
      font-size: .82rem;
    }
    .replyWrap{
      margin-top: 10px;
      margin-left: 14px;
      padding-left: 12px;
      border-left: 6px solid #e5e7eb;
      display: grid;
      gap: 10px;
    }
    .replyForm{
      margin-left: 14px;
      padding-left: 12px;
      border-left: 6px solid #e5e7eb;
      margin-top: 10px;
      display: grid;
      gap: 10px;
    }
    .charRow{
      display:flex; justify-content: space-between; gap: 10px; flex-wrap: wrap;
      color: #6b7280; font-weight: 800; font-size: .85rem;
    }

    /* ===== PIN / PROFILE UI ===== */
    .pinWrap{
      display:grid;
      gap:12px;
    }
    .pinDots{
      display:flex;
      justify-content:center;
      gap:10px;
      padding: 8px 0 2px;
      user-select:none;
    }
    .dot{
      width: 14px; height: 14px;
      border-radius: 999px;
      border: 2px solid #e5e7eb;
      background: #fff;
      box-shadow: 0 10px 22px rgba(0,0,0,.08);
    }
    .dot.filled{
      background: linear-gradient(135deg, #7c3aed, #fb7185);
      border-color: rgba(124,58,237,.25);
    }
    .pinKeypad{
      display:grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
    }
    .pinKey{
      height: 56px;
      border-radius: 16px;
      border: 1px solid #e5e7eb;
      background: #fff;
      font-weight: 1000;
      font-size: 1.25rem;
      cursor: pointer;
      box-shadow: 0 10px 22px rgba(0,0,0,.08);
      transition: transform .12s ease, filter .12s ease;
      user-select: none;
    }
    .pinKey:hover{ transform: translateY(-1px); filter: brightness(.99); }
    .pinKey:active{ transform: translateY(0px); }
    .pinKey.small{
      font-size: .95rem;
      font-weight: 950;
      letter-spacing: .02em;
    }
    .pinNote{
      text-align:center;
      color: var(--muted);
      font-weight: 750;
      font-size: .9rem;
      line-height: 1.35;
    }

    /* ‚úÖ sai m·∫≠t kh·∫©u: rung + ƒë·ªè dots (0.5s) */
    @keyframes shakeX {
      0% { transform: translateX(0); }
      15% { transform: translateX(-8px); }
      30% { transform: translateX(8px); }
      45% { transform: translateX(-6px); }
      60% { transform: translateX(6px); }
      75% { transform: translateX(-4px); }
      90% { transform: translateX(4px); }
      100% { transform: translateX(0); }
    }
    .pinWrap.shake { animation: shakeX .5s ease; }
    .pinDots.error .dot { border-color: rgba(220,38,38,.65); }
    .pinDots.error .dot.filled{
      background: linear-gradient(135deg, #fca5a5, #dc2626);
      border-color: rgba(220,38,38,.55);
    }
    .pinNote.error{ color: var(--bad); }

    .sectionTitle{
      font-weight: 1000;
      margin: 8px 0 6px;
      font-size: .98rem;
    }
    .divider{
      height:1px;
      background: #e5e7eb;
      margin: 12px 0;
    }
    .btn-red{
      background: var(--bad);
      color:#fff;
      border:0;
      box-shadow: 0 12px 24px rgba(220,38,38,.18);
    }
    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }
    @media (max-width: 520px){
      .grid2{ grid-template-columns: 1fr; }
    }

    @media (max-width: 820px) {
      .progressline { max-width: 100%; }
      .btn { padding: 9px 12px; font-size: .85rem; }
      .resultRow{ grid-template-columns: 120px 1fr; }
      .userCorner .name { max-width: 66vw; }
      .btn-check{ min-width: 84px; }
    }
  </style>
</head>

<body>
  <div class="userCorner" id="userCorner" title="B·∫•m ƒë·ªÉ m·ªü t√†i kho·∫£n">
    <span class="name" id="userCornerName">‚Äî</span>
    <span class="adminBadge" id="userCornerAdmin" style="display:none;">ADMIN</span>
  </div>

  <div id="shell">
    <div class="actionbar">
      <button class="btn" id="btnScrollTop">‚¨ÜÔ∏è L√™n ƒë·∫ßu</button>
      <button class="btn btn-primary" id="btnSubmit" disabled>üèÅ N·ªôp b√†i</button>
      <button class="btn btn-reset" id="btnReset">üîÅ L√†m l·∫°i</button>
    </div>

    <div class="wrap">
      <div class="topbar">
        <div class="titlebox">
          <div class="logo">Hi!</div>
          <div class="titles">
            <h1 id="quizTitle">Vocabulary</h1>
            <div class="tiny" id="quizSub"></div>
          </div>
        </div>

        <div class="stats">
          <div class="pill">ƒê√£ l√†m: <strong id="answeredCount">0</strong>/<span id="totalCount">0</span></div>
          <div class="progressline"><div class="progressfill" id="progressFill"></div></div>
        </div>
      </div>

      <div class="content" id="content"></div>
    </div>
  </div>

  <!-- Small Discuss Button (ONLY after finished) -->
  <div class="fabDiscuss" id="fabDiscuss">
    <button class="btn btn-discuss-mini" id="btnDiscuss">üí¨ Th·∫£o lu·∫≠n</button>
  </div>

  <div class="toast" id="toast"></div>

  <!-- Reset Confirmation Modal -->
  <div class="modal-backdrop" id="modalBackdrop" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
      <h3 id="modalTitle">L√†m l·∫°i b√†i?</h3>
      <p>X√≥a l·∫ßn hi·ªán t·∫°i v√† shuffle l·∫°i.</p>
      <div class="modal-actions">
        <button class="btn btn-ghost" id="btnCancel">H·ªßy</button>
        <button class="btn btn-danger" id="btnConfirmReset">X√≥a & L√†m l·∫°i</button>
      </div>
    </div>
  </div>

  <!-- ‚úÖ Register confirm -->
  <div class="modal-backdrop" id="registerBackdrop" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="registerTitle">
      <h3 id="registerTitle">ƒêƒÉng k√Ω t√†i kho·∫£n?</h3>
      <p id="registerDesc">Username ch∆∞a ƒëƒÉng k√Ω. B·∫°n c√≥ mu·ªën ƒëƒÉng k√Ω kh√¥ng?</p>
      <div class="modal-actions">
        <button class="btn btn-ghost" id="btnRegisterNo">Nh·∫≠p l·∫°i</button>
        <button class="btn btn-primary" id="btnRegisterYes">ƒêƒÉng k√Ω</button>
      </div>
    </div>
  </div>

  <!-- Wrong Answers Popup -->
  <div class="modal-backdrop" id="wrongBackdrop" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="wrongTitle">
      <div class="xclose">
        <button class="btn-x" id="btnCloseWrong" aria-label="ƒê√≥ng">‚úï</button>
      </div>
      <h3 id="wrongTitle">Nh·ªØng c√¢u sai</h3>
      <div id="wrongBody" style="display:grid; gap:12px;"></div>
    </div>
  </div>

  <!-- PIN Modal (keypad) -->
  <div class="modal-backdrop" id="pinBackdrop" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="pinTitle">
      <div class="xclose">
        <button class="btn-x" id="btnClosePin" aria-label="ƒê√≥ng">‚úï</button>
      </div>
      <h3 id="pinTitle">M·∫≠t kh·∫©u</h3>
      <p id="pinDesc">Nh·∫≠p m·∫≠t kh·∫©u s·ªë.</p>

      <div class="pinWrap" id="pinWrap">
        <div class="pinDots" id="pinDots"></div>
        <div class="pinKeypad" id="pinKeypad"></div>
        <div class="pinNote" id="pinNote"></div>
      </div>
    </div>
  </div>

  <!-- Profile Modal -->
  <div class="modal-backdrop" id="profileBackdrop" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="profileTitle">
      <div class="xclose">
        <button class="btn-x" id="btnCloseProfile" aria-label="ƒê√≥ng">‚úï</button>
      </div>
      <h3 id="profileTitle">T√†i kho·∫£n</h3>
      <p id="profileSub">Qu·∫£n l√Ω username & m·∫≠t kh·∫©u.</p>

      <div class="card" style="margin:10px 0 0; box-shadow:none;">
        <div class="row1">
          <p class="vi" style="margin:0">Username: <b id="profileUsername">‚Äî</b></p>
          <div class="meta"><span class="idx" id="profileRole">USER</span></div>
        </div>
        <div class="muted" id="profileRenameHint" style="margin-top:8px; line-height:1.35"></div>
      </div>

      <div class="divider"></div>

      <!-- ‚úÖ ƒê∆ØA M·∫¨T KH·∫®U L√äN TR√äN C√ôNG -->
      <div class="sectionTitle">M·∫≠t kh·∫©u</div>
      <div class="muted" style="margin:0 0 10px; line-height:1.35">
      </div>
      <button class="btn btn-primary" id="btnChangePin" style="justify-content:center; width:100%;">üîí ƒê·ªïi m·∫≠t kh·∫©u</button>

      <div class="divider"></div>

      <div class="sectionTitle">ƒê·ªïi username</div>
      <div class="muted" style="margin:0 0 10px; line-height:1.35">
      </div>

      <div class="grid2">
        <input class="input" id="newUsername" placeholder="Username m·ªõi" maxlength="15" autocomplete="off"/>
        <button class="btn btn-primary" id="btnSaveNewUsername" style="justify-content:center;">üíæ L∆∞u username</button>
      </div>

      <div class="divider"></div>

      <button class="btn btn-red" id="btnLogout" style="justify-content:center; width:100%;">üö™ ƒêƒÉng xu·∫•t</button>
    </div>
  </div>

<script>
/********************
 * 0) SET API URL (Apps Script Web App)
 ********************/
const API_URL = "https://script.google.com/macros/s/AKfycbz-qpw7O50e1cMSkeYyPuieGXuesBLyF8LzJ6asr03ESQXkZqP2vivVZGcG-TBXDIHW4g/exec";

/********************
 * Username rules
 ********************/
const USER_KEY = "tk_user_v1";
const BAD_SUBSTRINGS = ["duma","dit","lon","cac","fuck","shit","dick","pussy"];
const ADMIN_NORM = "tuankhoi";

/********************
 * Special admin pin (front-end fallback)
 ********************/
const ADMIN_PIN = "072008"; // tuankhoi: 6 s·ªë

/********************
 * Quiz id
 ********************/
function getQuizId() {
  try {
    const u = new URL(location.href);
    const q = (u.searchParams.get("quiz") || "").trim();
    return q || "vocab1";
  } catch { return "vocab1"; }
}

/********************
 * POST JSON
 ********************/
async function postJSON(payload) {
  const res = await fetch(API_URL, {
    method: "POST",
    headers: { "Content-Type": "text/plain;charset=UTF-8" },
    body: JSON.stringify(payload),
  });
  const txt = await res.text();
  let data;
  try { data = JSON.parse(txt); }
  catch { throw new Error("API kh√¥ng tr·∫£ JSON."); }
  if (data && data.ok === false) throw new Error(data.error || "API error");
  return data;
}

/********************
 * Polyfill google.script.run
 ********************/
function installGoogleScriptRunPolyfill() {
  window.google = window.google || {};
  window.google.script = window.google.script || {};

  function runner(success, failure) {
    return new Proxy({}, {
      get(_t, prop) {
        if (prop === "withSuccessHandler") return (fn) => runner(fn, failure);
        if (prop === "withFailureHandler") return (fn) => runner(success, fn);

        return (arg) => {
          const action = String(prop);

          let payload = {};
          if (arg && typeof arg === "object") payload = { ...arg };
          else {
            if (action === "getLeaderboard") payload = { limit: arg };
            else if (action === "getProgress") payload = { cacheId: arg };
            else payload = {};
          }

          if (action === "getQuizData" && !payload.quizId) payload.quizId = getQuizId();

          const p = postJSON({ action, ...payload })
            .then((data) => {
              success && success(data);
              return data;
            })
            .catch((err) => {
              const e = (err instanceof Error) ? err : new Error(String(err));
              failure && failure(e);
              throw e;
            });

          return p;
        };
      }
    });
  }

  window.google.script.run = runner(null, null);
}

function gasAvailable() {
  return !!(API_URL && API_URL.startsWith("http"));
}

/********************
 * User local cache (‚úÖ migrate d·ªØ li·ªáu c≈©)
 ********************/
function normalizeUserObj_(u){
  if (!u || typeof u !== "object") return null;

  // migrate keys c≈©: {id, name}
  const userId = String(u.userId || u.id || "").trim();
  const username = String(u.username || u.name || "").trim();
  const lastRenameAtMs = Number(u.lastRenameAtMs || 0) || 0;

  if (!userId || !username) return null;
  return { userId, username, lastRenameAtMs };
}

function loadUser() {
  try {
    const raw = localStorage.getItem(USER_KEY) || "null";
    const obj = JSON.parse(raw);
    const u = normalizeUserObj_(obj);
    // n·∫øu migrate ƒë∆∞·ª£c th√¨ l∆∞u l·∫°i chu·∫©n lu√¥n
    if (u) localStorage.setItem(USER_KEY, JSON.stringify(u));
    return u;
  } catch { return null; }
}

function saveUser(u) {
  if (!u) localStorage.removeItem(USER_KEY);
  else {
    const norm = normalizeUserObj_(u) || null;
    if (!norm) localStorage.removeItem(USER_KEY);
    else localStorage.setItem(USER_KEY, JSON.stringify(norm));
  }
}

/********************
 * Username normalize
 ********************/
function normalizeForFilter(s) {
  let t = String(s || "").trim().toLowerCase();
  t = t.replace(/ƒë/g, "d");
  try { t = t.normalize("NFKD").replace(/[\u0300-\u036f]/g, ""); } catch {}
  t = t.replace(/0/g, "o").replace(/1/g, "l").replace(/3/g, "e").replace(/4/g, "a").replace(/5/g, "s").replace(/7/g, "t");
  t = t.replace(/[^a-z0-9_]/g, "");
  return t;
}
function isBadUsername(u) {
  const t = normalizeForFilter(u);
  for (const w of BAD_SUBSTRINGS) if (t.includes(w)) return true;
  return false;
}
function validateUsername(u) {
  u = String(u || "").trim();
  if (!u) return "Ch∆∞a nh·∫≠p username.";
  if (u.length > 15) return "Username t·ªëi ƒëa 15 k√Ω t·ª±.";
  if (!/^[A-Za-z0-9_]+$/.test(u)) return "Ch·ªâ ƒë∆∞·ª£c d√πng a-z A-Z 0-9 v√† d·∫•u _";
  if (isBadUsername(u)) return "Username c√≥ ch·ª©a t·ª´ kh√¥ng ph√π h·ª£p.";
  return null;
}
function isAdminName(nameLike){
  return normalizeForFilter(nameLike) === ADMIN_NORM;
}

/********************
 * Helpers
 ********************/
function escapeHtml(s) {
  return String(s ?? "")
    .replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;").replace(/'/g, "&#39;");
}
function toast(msg) {
  const t = document.getElementById("toast");
  t.textContent = msg;
  t.classList.add("show");
  setTimeout(() => t.classList.remove("show"), 1200);
}
function shuffle(arr) {
  const a = arr.slice();
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}
function randId(prefix = "id") {
  return prefix + "_" + Math.random().toString(16).slice(2) + "_" + Date.now().toString(16);
}
function normalizeName(s){
  return String(s||"").trim().replace(/\s+/g," ").toLowerCase();
}
function answerKey(s){
  return String(s||"").trim().replace(/\s+/g," ").toLowerCase();
}
function pad2(n){ return String(n).padStart(2,"0"); }
function formatTs(ms){
  const d = new Date(Number(ms||0));
  const hh = pad2(d.getHours());
  const mm = pad2(d.getMinutes());
  const dd = pad2(d.getDate());
  const MM = pad2(d.getMonth()+1);
  const yy = String(d.getFullYear()).slice(-2);
  return `${hh}:${mm}/${dd}/${MM}/${yy}`;
}
function isDigitsOnly(s){
  return /^[0-9]+$/.test(String(s||""));
}

/********************
 * ‚úÖ Register confirm modal
 ********************/
const registerBackdrop = document.getElementById("registerBackdrop");
const registerDesc = document.getElementById("registerDesc");
document.getElementById("btnRegisterNo").addEventListener("click", () => closeRegisterPrompt_(false));
document.getElementById("btnRegisterYes").addEventListener("click", () => closeRegisterPrompt_(true));
registerBackdrop.addEventListener("click", (e) => { if (e.target === registerBackdrop) closeRegisterPrompt_(false); });

let REG_PROMPT = { open:false, resolve:null, username:"" };
function openRegisterPrompt_(username){
  return new Promise((resolve) => {
    REG_PROMPT.open = true;
    REG_PROMPT.resolve = resolve;
    REG_PROMPT.username = String(username||"").trim();

    registerDesc.textContent = `Username "${REG_PROMPT.username}" ch∆∞a ƒëƒÉng k√Ω, b·∫°n c√≥ mu·ªën ƒëƒÉng k√Ω kh√¥ng?`;
    registerBackdrop.classList.add("show");
    registerBackdrop.setAttribute("aria-hidden","false");
  });
}
function closeRegisterPrompt_(ans){
  if (!REG_PROMPT.open) return;
  registerBackdrop.classList.remove("show");
  registerBackdrop.setAttribute("aria-hidden","true");

  const res = REG_PROMPT.resolve;
  REG_PROMPT.open = false;
  REG_PROMPT.resolve = null;
  REG_PROMPT.username = "";

  if (res) res(!!ans);
}

/********************
 * PIN Modal (keypad) - nhanh h∆°n (keypad build 1 l·∫ßn)
 ********************/
const pinBackdrop = document.getElementById("pinBackdrop");
const pinTitle = document.getElementById("pinTitle");
const pinDesc = document.getElementById("pinDesc");
const pinDots = document.getElementById("pinDots");
const pinKeypad = document.getElementById("pinKeypad");
const pinNote = document.getElementById("pinNote");
const pinWrap = document.getElementById("pinWrap");

document.getElementById("btnClosePin").addEventListener("click", () => closePinModal_("cancel"));

let PIN_KEYS_BUILT = false;

let PIN_MODAL = {
  open: false,
  resolve: null,
  reject: null,
  username: "",
  mode: "login", // login | set | change
  step: "one",   // set: one|confirm ; change: old|new1|confirm
  pinLen: 4,
  value: "",
  first: "",
  old: "",
  dotEls: [],
  submitting: false,
  noteDefault: "",
  onSubmit: null,        // login: async(pin) => {ok, data?, message?}
  onVerifyOld: null,     // change: async(oldPin) => {ok, message?}
  onFinalizeChange: null // change: async({oldPin,newPin}) => {ok, message?, resetStep?}
};

function buildPinKeypadOnce_(){
  if (PIN_KEYS_BUILT) return;
  PIN_KEYS_BUILT = true;

  pinKeypad.innerHTML = "";
  const keys = ["1","2","3","4","5","6","7","8","9","CLEAR","0","‚å´"];
  keys.forEach(k => {
    const b = document.createElement("button");
    b.className = "pinKey" + ((k==="CLEAR"||k==="‚å´") ? " small" : "");
    b.type = "button";
    b.textContent = k;
    b.addEventListener("click", () => onPinKey_(k));
    pinKeypad.appendChild(b);
  });
}

function buildDots_(n){
  pinDots.innerHTML = "";
  PIN_MODAL.dotEls = [];
  for (let i=0;i<n;i++){
    const d = document.createElement("div");
    d.className = "dot";
    pinDots.appendChild(d);
    PIN_MODAL.dotEls.push(d);
  }
}

function updateDots_(){
  const valLen = PIN_MODAL.value.length;
  for (let i=0;i<PIN_MODAL.dotEls.length;i++){
    const el = PIN_MODAL.dotEls[i];
    if (!el) continue;
    el.classList.toggle("filled", i < valLen);
  }
}

function setPinNote_(msg, type=""){
  if (type === "error") pinNote.classList.add("error");
  else pinNote.classList.remove("error");
  pinNote.textContent = String(msg || "");
}

function pinErrorPulse_(msg){
  // clear nh·∫≠p hi·ªán t·∫°i + rung + ƒë·ªè dots trong 0.5s, kh√¥ng ƒë√≥ng modal
  PIN_MODAL.value = "";
  updateDots_();

  pinDots.classList.add("error");
  if (pinWrap) {
    pinWrap.classList.remove("shake");
    void pinWrap.offsetWidth; // retrigger
    pinWrap.classList.add("shake");
  }
  setPinNote_(msg || "Sai m·∫≠t kh·∫©u", "error");

  setTimeout(() => {
    pinDots.classList.remove("error");
    if (pinWrap) pinWrap.classList.remove("shake");
    setPinNote_(PIN_MODAL.noteDefault || "");
  }, 520);
}

function updatePinHeader_(){
  const u = PIN_MODAL.username || "";
  const mode = PIN_MODAL.mode;

  let title = "";
  let desc = "";

  if (mode === "login") {
    title = "ƒêƒÉng nh·∫≠p";
    desc = `Username: ${u}`;
  } else if (mode === "set") {
    if (PIN_MODAL.step === "one") {
      title = "ƒêƒÉng k√Ω";
      desc = `T·∫°o m·∫≠t kh·∫©u ${PIN_MODAL.pinLen} s·ªë`;
    } else {
      title = "X√°c nh·∫≠n m·∫≠t kh·∫©u";
      desc = `Nh·∫≠p l·∫°i ${PIN_MODAL.pinLen} s·ªë`;
    }
  } else if (mode === "change") {
    if (PIN_MODAL.step === "old") {
      title = "ƒê·ªïi m·∫≠t kh·∫©u";
      desc = "Nh·∫≠p m·∫≠t kh·∫©u hi·ªán t·∫°i";
    } else if (PIN_MODAL.step === "new1") {
      title = "M·∫≠t kh·∫©u m·ªõi";
      desc = `Nh·∫≠p ${PIN_MODAL.pinLen} s·ªë`;
    } else {
      title = "X√°c nh·∫≠n m·∫≠t kh·∫©u m·ªõi";
      desc = `Nh·∫≠p l·∫°i ${PIN_MODAL.pinLen} s·ªë`;
    }
  }

  pinTitle.textContent = title;
  pinDesc.textContent = desc;

  // default note
  if (isAdminName(u) || isAdminName(state.name)) {
    PIN_MODAL.noteDefault = `T√†i kho·∫£n tuankhoi d√πng m·∫≠t kh·∫©u 6 s·ªë.`;
  } else {
    PIN_MODAL.noteDefault = `M·∫≠t kh·∫©u ch·ªâ g·ªìm s·ªë.`;
  }
  setPinNote_(PIN_MODAL.noteDefault);
}

function openPinModal_({ username, mode="login", pinLen=4, firstPin="", onSubmit=null, onVerifyOld=null, onFinalizeChange=null }){
  return new Promise((resolve, reject) => {
    PIN_MODAL.open = true;
    PIN_MODAL.resolve = resolve;
    PIN_MODAL.reject = reject;

    PIN_MODAL.username = String(username||"").trim();
    PIN_MODAL.mode = mode;
    PIN_MODAL.pinLen = Math.max(4, Number(pinLen)||4);

    PIN_MODAL.value = "";
    PIN_MODAL.first = "";
    PIN_MODAL.old = "";
    PIN_MODAL.submitting = false;

    PIN_MODAL.onSubmit = (typeof onSubmit === "function") ? onSubmit : null;
    PIN_MODAL.onVerifyOld = (typeof onVerifyOld === "function") ? onVerifyOld : null;
    PIN_MODAL.onFinalizeChange = (typeof onFinalizeChange === "function") ? onFinalizeChange : null;

    if (mode === "set") {
      if (firstPin) {
        PIN_MODAL.first = String(firstPin||"");
        PIN_MODAL.step = "confirm";
      } else {
        PIN_MODAL.step = "one";
      }
    } else if (mode === "change") {
      PIN_MODAL.step = "old";
    } else {
      PIN_MODAL.step = "one";
    }

    buildPinKeypadOnce_();
    buildDots_(PIN_MODAL.pinLen);
    updatePinHeader_();
    updateDots_();

    pinBackdrop.classList.add("show");
    pinBackdrop.setAttribute("aria-hidden", "false");
  });
}

function closePinModal_(why){
  if (!PIN_MODAL.open) return;

  pinBackdrop.classList.remove("show");
  pinBackdrop.setAttribute("aria-hidden", "true");

  const rej = PIN_MODAL.reject;

  PIN_MODAL.open = false;
  PIN_MODAL.resolve = null;
  PIN_MODAL.reject = null;

  PIN_MODAL.submitting = false;
  PIN_MODAL.onSubmit = null;
  PIN_MODAL.onVerifyOld = null;
  PIN_MODAL.onFinalizeChange = null;

  if (why === "ok") return;
  if (rej) rej(new Error("cancel"));
}

pinBackdrop.addEventListener("click", (e) => {
  if (e.target === pinBackdrop) closePinModal_("cancel");
});

async function submitLoginOrStay_(pin){
  if (!PIN_MODAL.onSubmit) return null;

  if (PIN_MODAL.submitting) return null;
  PIN_MODAL.submitting = true;

  try{
    setPinNote_("ƒêang ki·ªÉm tra‚Ä¶");
    pinNote.classList.remove("error");

    const out = await PIN_MODAL.onSubmit(pin);
    if (out && out.ok) {
      const data = (out.data !== undefined) ? out.data : pin;
      const res = PIN_MODAL.resolve;
      closePinModal_("ok");
      if (res) res(data);
      return true;
    }
    pinErrorPulse_((out && out.message) ? out.message : "Sai m·∫≠t kh·∫©u");
    return false;
  } catch(e){
    pinErrorPulse_("Sai m·∫≠t kh·∫©u");
    return false;
  } finally {
    PIN_MODAL.submitting = false;
  }
}

async function verifyOldOrStay_(oldPin){
  if (!PIN_MODAL.onVerifyOld) return true;

  if (PIN_MODAL.submitting) return false;
  PIN_MODAL.submitting = true;

  try{
    setPinNote_("ƒêang ki·ªÉm tra‚Ä¶");
    pinNote.classList.remove("error");

    const out = await PIN_MODAL.onVerifyOld(oldPin);
    if (out && out.ok) return true;

    pinErrorPulse_((out && out.message) ? out.message : "Sai m·∫≠t kh·∫©u");
    return false;
  } catch(e){
    pinErrorPulse_("Sai m·∫≠t kh·∫©u");
    return false;
  } finally {
    PIN_MODAL.submitting = false;
  }
}

async function finalizeChangeOrStay_(payload){
  if (!PIN_MODAL.onFinalizeChange) return { ok:true };

  if (PIN_MODAL.submitting) return { ok:false, message:"ƒêang x·ª≠ l√Ω‚Ä¶" };
  PIN_MODAL.submitting = true;

  try{
    setPinNote_("ƒêang l∆∞u‚Ä¶");
    pinNote.classList.remove("error");

    const out = await PIN_MODAL.onFinalizeChange(payload);
    if (out && out.ok) return { ok:true };

    return { ok:false, message: (out && out.message) ? out.message : "Kh√¥ng ƒë·ªïi ƒë∆∞·ª£c", resetStep: (out && out.resetStep) ? out.resetStep : "old" };
  } catch(e){
    return { ok:false, message:"Kh√¥ng ƒë·ªïi ƒë∆∞·ª£c", resetStep:"old" };
  } finally {
    PIN_MODAL.submitting = false;
  }
}

async function onPinKey_(k){
  if (!PIN_MODAL.open) return;
  if (PIN_MODAL.submitting) return; // ƒëang check -> kh√≥a keypad

  if (k === "CLEAR") {
    PIN_MODAL.value = "";
    updateDots_();
    return;
  }
  if (k === "‚å´") {
    PIN_MODAL.value = PIN_MODAL.value.slice(0, -1);
    updateDots_();
    return;
  }

  if (PIN_MODAL.value.length >= PIN_MODAL.pinLen) return;
  PIN_MODAL.value += String(k);
  updateDots_();

  if (PIN_MODAL.value.length !== PIN_MODAL.pinLen) return;

  const mode = PIN_MODAL.mode;

  if (mode === "login") {
    const pin = PIN_MODAL.value;

    // ‚úÖ Sai th√¨ rung + ƒë·ªè v√† KH√îNG ƒë√≥ng modal
    if (PIN_MODAL.onSubmit) {
      await submitLoginOrStay_(pin);
      return;
    }

    // fallback c≈© (n·∫øu kh√¥ng truy·ªÅn onSubmit)
    const res = PIN_MODAL.resolve;
    closePinModal_("ok");
    if (res) res(pin);
    return;
  }

  if (mode === "set") {
    if (PIN_MODAL.step === "one") {
      PIN_MODAL.first = PIN_MODAL.value;
      PIN_MODAL.value = "";
      PIN_MODAL.step = "confirm";
      updatePinHeader_();
      updateDots_();
      return;
    } else {
      const pin1 = PIN_MODAL.first;
      const pin2 = PIN_MODAL.value;

      if (pin1 !== pin2) {
        // ‚úÖ mismatch -> ƒë·ªè + rung, ·ªü l·∫°i modal
        pinErrorPulse_("M·∫≠t kh·∫©u kh√¥ng kh·ªõp");
        PIN_MODAL.value = "";
        PIN_MODAL.first = "";
        PIN_MODAL.step = "one";
        updatePinHeader_();
        updateDots_();
        return;
      }

      const res = PIN_MODAL.resolve;
      closePinModal_("ok");
      if (res) res(pin2);
      return;
    }
  }

  if (mode === "change") {
    if (PIN_MODAL.step === "old") {
      const oldPin = PIN_MODAL.value;

      // ‚úÖ verify old pin (sai -> ƒë·ªè + rung, kh√¥ng ƒë√≥ng)
      const ok = await verifyOldOrStay_(oldPin);
      if (!ok) {
        PIN_MODAL.value = "";
        PIN_MODAL.old = "";
        PIN_MODAL.step = "old";
        updatePinHeader_();
        updateDots_();
        return;
      }

      PIN_MODAL.old = oldPin;
      PIN_MODAL.value = "";
      PIN_MODAL.step = "new1";
      updatePinHeader_();
      updateDots_();
      return;
    }

    if (PIN_MODAL.step === "new1") {
      PIN_MODAL.first = PIN_MODAL.value;
      PIN_MODAL.value = "";
      PIN_MODAL.step = "confirm";
      updatePinHeader_();
      updateDots_();
      return;
    }

    const new1 = PIN_MODAL.first;
    const new2 = PIN_MODAL.value;

    if (new1 !== new2) {
      pinErrorPulse_("M·∫≠t kh·∫©u m·ªõi kh√¥ng kh·ªõp");
      PIN_MODAL.value = "";
      PIN_MODAL.first = "";
      PIN_MODAL.step = "new1";
      updatePinHeader_();
      updateDots_();
      return;
    }

    // ‚úÖ finalize change (server) -> fail th√¨ ·ªü l·∫°i modal + rung
    const out = await finalizeChangeOrStay_({ oldPin: PIN_MODAL.old, newPin: new2 });
    if (!out || !out.ok) {
      pinErrorPulse_(out && out.message ? out.message : "Kh√¥ng ƒë·ªïi ƒë∆∞·ª£c");

      // reset step n·∫øu mu·ªën
      const resetStep = (out && out.resetStep) ? out.resetStep : "old";
      if (resetStep === "new1") {
        PIN_MODAL.step = "new1";
        PIN_MODAL.value = "";
        PIN_MODAL.first = "";
      } else {
        PIN_MODAL.step = "old";
        PIN_MODAL.value = "";
        PIN_MODAL.first = "";
        PIN_MODAL.old = "";
      }
      updatePinHeader_();
      updateDots_();
      return;
    }

    const res = PIN_MODAL.resolve;
    closePinModal_("ok");
    if (res) res({ oldPin: PIN_MODAL.old, newPin: new2 });
    return;
  }
}

/********************
 * Profile Modal
 ********************/
const profileBackdrop = document.getElementById("profileBackdrop");
document.getElementById("btnCloseProfile").addEventListener("click", closeProfileModal_);
profileBackdrop.addEventListener("click", (e) => { if (e.target === profileBackdrop) closeProfileModal_(); });

function openProfileModal_(){
  if (!state.name) return;

  document.getElementById("profileUsername").textContent = state.name;
  document.getElementById("profileRole").textContent = isAdminName(state.name) ? "ADMIN" : "USER";
  document.getElementById("profileSub").textContent = "Qu·∫£n l√Ω t√†i kho·∫£n";

  const hintEl = document.getElementById("profileRenameHint");
  const newUsernameEl = document.getElementById("newUsername");
  const btnSaveNewUsernameEl = document.getElementById("btnSaveNewUsername");

  // ‚úÖ kh√≥a ƒë·ªïi username v·ªõi tuankhoi
  if (isAdminName(state.name)) {
    hintEl.textContent = "T√†i kho·∫£n tuankhoi kh√¥ng ƒë∆∞·ª£c ƒë·ªïi username.";
    if (newUsernameEl) {
      newUsernameEl.value = "";
      newUsernameEl.disabled = true;
      newUsernameEl.placeholder = "Kh√¥ng √°p d·ª•ng cho tuankhoi";
    }
    if (btnSaveNewUsernameEl) btnSaveNewUsernameEl.disabled = true;
  } else {
    const last = Number((USER && USER.lastRenameAtMs) ? USER.lastRenameAtMs : 0) || 0;
    const now = Date.now();
    const DAY = 24*60*60*1000;
    const nextOk = last ? (last + 30*DAY) : 0;
    const canRename = (!last) || (now >= nextOk);

    if (canRename) hintEl.textContent = "C√≥ th·ªÉ ƒë·ªïi  username ngay b√¢y gi·ªù.";
    else hintEl.textContent = "C√≥ th·ªÉ ƒë·ªïi  username v√†o " + formatTs(nextOk);

    if (newUsernameEl) {
      newUsernameEl.disabled = false;
      newUsernameEl.placeholder = "Username m·ªõi";
    }
    if (btnSaveNewUsernameEl) btnSaveNewUsernameEl.disabled = false;
  }

  document.getElementById("newUsername").value = "";

  profileBackdrop.classList.add("show");
  profileBackdrop.setAttribute("aria-hidden","false");
}
function closeProfileModal_(){
  profileBackdrop.classList.remove("show");
  profileBackdrop.setAttribute("aria-hidden","true");
}

/********************
 * Persist (same)
 ********************/
const STORAGE_KEY = "gs_vocab_check_progress_v2";
const DB_NAME = "gs_vocab_check_db_v2";
const STORE_NAME = "kv";
const NAME_PREFIX = "GSV2::";

const Persist = {
  mode: { local: false, session: false, idb: false },
  db: null,

  async init() {
    try { const k = "__t__"; localStorage.setItem(k, "1"); localStorage.removeItem(k); this.mode.local = true; } catch (e) {}
    try { const k = "__t__"; sessionStorage.setItem(k, "1"); sessionStorage.removeItem(k); this.mode.session = true; } catch (e) {}
    try {
      this.db = await this.openDB();
      await this.idbSet("__t__", "1");
      await this.idbRemove("__t__");
      this.mode.idb = true;
    } catch (e) {
      this.mode.idb = false;
      this.db = null;
    }
  },

  mirrorToWindowName(rawJson) {
    try { window.name = NAME_PREFIX + rawJson; } catch (e) {}
  },
  mirrorGet() {
    try {
      const n = window.name || "";
      if (n.startsWith(NAME_PREFIX)) return n.slice(NAME_PREFIX.length);
    } catch (e) {}
    return null;
  },

  async set(key, value, { mirror = false } = {}) {
    if (mirror) this.mirrorToWindowName(value);
    if (this.mode.local) { try { localStorage.setItem(key, value); } catch (e) {} }
    if (this.mode.idb && this.db) { try { await this.idbSet(key, value); } catch (e) {} }
    if (this.mode.session) { try { sessionStorage.setItem(key, value); } catch (e) {} }
  },

  async remove(key) {
    try { if ((window.name || "").startsWith(NAME_PREFIX)) window.name = ""; } catch (e) {}
    try { localStorage.removeItem(key); } catch (e) {}
    try { sessionStorage.removeItem(key); } catch (e) {}
    if (this.mode.idb && this.db) { try { await this.idbRemove(key); } catch (e) {} }
  },

  openDB() {
    return new Promise((resolve, reject) => {
      const req = indexedDB.open(DB_NAME, 1);
      req.onupgradeneeded = () => {
        const db = req.result;
        if (!db.objectStoreNames.contains(STORE_NAME)) db.createObjectStore(STORE_NAME);
      };
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
  },
  idbTx(mode, fn) {
    return new Promise((resolve, reject) => {
      const tx = this.db.transaction(STORE_NAME, mode);
      const store = tx.objectStore(STORE_NAME);
      const req = fn(store);
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
  },
  idbSet(key, val) { return this.idbTx("readwrite", s => s.put(val, key)); },
  idbRemove(key) { return this.idbTx("readwrite", s => s.delete(key)); },
};

/********************
 * Quiz Data
 ********************/
let QUIZ = { title: "Vocabulary", sub: "", vocabs: [], requireAccessCode: false, quizId: getQuizId() };
let VMAP = new Map();
let QUIZ_LOADED = false;

/********************
 * State
 ********************/
const QUIZ_VERSION = "vocab-check-v2";

let state = {
  quizVersion: QUIZ_VERSION,
  cacheId: "",
  name: "",
  accessCode: "",
  attemptId: "",
  order: [],
  answers: {},
  checked: {},
  finalized: false,
  result: null,
  history: [],
  ts: 0
};

let USER = null;

/********************
 * View control
 ********************/
let CURRENT_VIEW = "boot"; // boot|gate|quiz|result
function setView(v){
  CURRENT_VIEW = v;
  const btnSubmit = document.getElementById("btnSubmit");
  if (btnSubmit) {
    btnSubmit.style.display = (v === "quiz") ? "inline-flex" : "none";
  }
}

/********************
 * Stable cacheId + attempt
 ********************/
function ensureCacheId() {
  if (USER && USER.userId) {
    state.cacheId = USER.userId;
    try { location.hash = "cache=" + encodeURIComponent(state.cacheId); } catch (e) {}
    return;
  }
  if (state.cacheId && String(state.cacheId).trim()) return;
  state.cacheId = randId("cache");
  try { location.hash = "cache=" + encodeURIComponent(state.cacheId); } catch (e) {}
}
function newAttempt() {
  state.attemptId = randId("attempt");
  state.order = shuffle(QUIZ.vocabs.map(v => v.id));
  state.answers = {};
  state.checked = {};
  state.finalized = false;
  state.result = null;
  state.ts = Date.now();
}

/********************
 * Save local
 ********************/
let saveTimer = null;
function scheduleSave({ mirror = false } = {}) {
  if (saveTimer) clearTimeout(saveTimer);
  saveTimer = setTimeout(async () => {
    state.ts = Date.now();
    const raw = JSON.stringify(state);
    await Persist.set(STORAGE_KEY, raw, { mirror });
  }, 120);
}

/********************
 * Cloud save (throttle) + autosave 30s
 ********************/
let lastCloud = 0;
function scheduleCloudSave() {
  if (!gasAvailable()) return;
  if (!state || !state.cacheId) return;
  if (!state.name) return;

  const now = Date.now();
  if (now - lastCloud < 1500) return;
  lastCloud = now;

  try {
    google.script.run.saveProgress({
      cacheId: state.cacheId,
      name: state.name || "",
      stateJson: JSON.stringify(state),
      userId: (USER && USER.userId) ? USER.userId : "",
      quizId: QUIZ.quizId || getQuizId()
    });
  } catch(e){}
}
let cloudInterval = null;
function startCloudAutosave(){
  if (cloudInterval) return;
  cloudInterval = setInterval(() => {
    scheduleCloudSave();
  }, 30000);
}

/********************
 * Stats + username corner
 ********************/
function answeredCount() {
  let c = 0;
  const order = state.order && state.order.length ? state.order : (QUIZ.vocabs||[]).map(v=>v.id);
  for (const id of order) {
    const v = String(state.answers[id] ?? "").trim();
    if (v) c++;
  }
  return c;
}
function totalCount() { return QUIZ.vocabs.length; }

function updateUserCorner(){
  const box = document.getElementById("userCorner");
  const nm = document.getElementById("userCornerName");
  const ad = document.getElementById("userCornerAdmin");

  const name = state.name || (USER && USER.username) || "";
  if (!name) {
    box.style.display = "none";
    return;
  }
  box.style.display = "inline-flex";
  nm.textContent = name;
  ad.style.display = isAdminName(name) ? "inline-flex" : "none";
}

function setDiscussFabVisible(show){
  const fab = document.getElementById("fabDiscuss");
  fab.style.display = show ? "block" : "none";
}

function updateStats() {
  updateUserCorner();

  document.getElementById("answeredCount").textContent = answeredCount();
  document.getElementById("totalCount").textContent = totalCount();
  document.getElementById("progressFill").style.width =
    (totalCount() ? Math.round((answeredCount() / totalCount()) * 100) : 0) + "%";

  const canSubmit = !!state.name && !state.finalized && answeredCount() > 0;
  const btnSubmit = document.getElementById("btnSubmit");
  if (btnSubmit) btnSubmit.disabled = !canSubmit;

  setDiscussFabVisible(!!(state.finalized));
}

/********************
 * Views
 ********************/
const content = document.getElementById("content");

/* Boot loading screen with dots . .. ... */
let BOOT_LOADER = { timer: null, dots: 1 };
function showBootLoading(msg){
  setView("boot");
  content.innerHTML = "";
  const c = document.createElement("div");
  c.className = "card";
  c.innerHTML = `
    <div class="row1">
      <p class="vi" id="bootTitle">${escapeHtml(msg || "ƒêang t·∫£i quiz, ƒë·ª£i x√≠u nha")}</p>
      <div class="meta"><span class="idx">LOADING</span></div>
    </div>
    <div class="muted" style="margin-top:8px; line-height:1.35">
      Vui l√≤ng ch·ªù<span id="bootDots">.</span>
    </div>
  `;
  content.appendChild(c);

  const dotsEl = document.getElementById("bootDots");
  BOOT_LOADER.dots = 1;
  if (BOOT_LOADER.timer) clearInterval(BOOT_LOADER.timer);
  BOOT_LOADER.timer = setInterval(() => {
    if (!dotsEl) return;
    BOOT_LOADER.dots = (BOOT_LOADER.dots % 3) + 1;
    dotsEl.textContent = ".".repeat(BOOT_LOADER.dots);
  }, 420);
}
function setBootLoadingMsg(msg){
  const t = document.getElementById("bootTitle");
  if (t) t.textContent = String(msg || "");
}
function hideBootLoading(){
  if (BOOT_LOADER.timer) clearInterval(BOOT_LOADER.timer);
  BOOT_LOADER.timer = null;
}

/* Gate state */
let GATE = { ready: false, status: "S·∫µn s√†ng." };
function setGateStatus(msg){
  GATE.status = String(msg||"");
  const el = document.getElementById("gateStatus");
  if (el) el.textContent = GATE.status;
}
function setGateReady(ready){
  GATE.ready = !!ready;
  const btn = document.getElementById("btnEnter");
  if (btn) btn.disabled = !GATE.ready;
}

/********************
 * Account API (‚úÖ g·ª≠i c·∫£ password ƒë·ªÉ match sheet)
 ********************/
function buildAuthFields_(pinLike){
  const p = String(pinLike ?? "");
  return {
    pin: p,
    password: p,
    pass: p,
    pwd: p,
    pincode: p,
    pinCode: p
  };
}
function extractServerPassword_(obj){
  if (!obj || typeof obj !== "object") return "";
  return String(
    obj.password ??
    obj.pass ??
    obj.pwd ??
    obj.pin ??
    obj.pincode ??
    obj.pinCode ??
    ""
  );
}
function pickExists_(ck){
  if (!ck) return null;
  if (typeof ck.exists === "boolean") return ck.exists;
  if (ck.ok === true && typeof ck.exists === "boolean") return ck.exists;
  return null;
}
function pickUserId_(ck){
  if (!ck) return "";
  return String(ck.userId || (ck.user && ck.user.userId) || (ck.user && ck.user.id) || ck.id || "");
}
function pickPinLen_(ck){
  if (!ck) return 0;
  return Number(ck.pinLen || (ck.user && ck.user.pinLen) || 0) || 0;
}

async function apiCheckUsername_(username){
  const u = String(username||"").trim();
  return await postJSON({ action:"checkUsername", username: u, name: u, userName: u });
}

async function apiLoginUser_(username, pin){
  const u = String(username||"").trim();
  const p = String(pin||"");
  return await postJSON({
    action:"loginUser",
    username: u,
    name: u,
    userName: u,
    ...buildAuthFields_(p),
    ua: navigator.userAgent || ""
  });
}

async function apiRegisterUser_(username, pin){
  const userId = randId("u");
  const u = String(username||"").trim();
  const p = String(pin||"");
  return await postJSON({
    action:"registerUser",
    userId,
    username: u,
    name: u,
    userName: u,
    ...buildAuthFields_(p),
    ua: navigator.userAgent || ""
  });
}

/* ‚úÖ ƒë·ªïi signature ƒë·ªÉ kh√¥ng b·ªã d√≠nh state.name khi optimistic */
async function apiChangeUsername_(oldUsername, newUsername){
  return await postJSON({
    action:"changeUsername",
    userId: (USER && USER.userId) ? USER.userId : "",
    oldUsername: String(oldUsername||"").trim(),
    username: String(oldUsername||"").trim(),     // th√™m field ƒë·ªÉ backend c≈© c≈©ng hi·ªÉu
    newUsername: String(newUsername||"").trim(),
    ua: navigator.userAgent || ""
  });
}

async function apiChangePassword_(username, oldPin, newPin){
  const u = String(username||"").trim();
  const o = String(oldPin||"");
  const n = String(newPin||"");

  return await postJSON({
    action:"changePassword",
    userId: (USER && USER.userId) ? USER.userId : "",
    username: u,
    name: u,
    userName: u,
    oldPin: o,
    newPin: n,
    oldPassword: o,
    newPassword: n,
    oldPass: o,
    newPass: n,
    ua: navigator.userAgent || ""
  });
}

/********************
 * Gate view
 ********************/
function renderGateView() {
  setView("gate");
  setDiscussFabVisible(false);
  content.innerHTML = "";

  const knownName = (USER && USER.username) ? USER.username : (state.name || "");
  const hasName = !!knownName;

  const c = document.createElement("div");
  c.className = "card";

  if (hasName) {
    const admin = isAdminName(knownName);
    const buttonLabel = (state.finalized && state.result) ? "üìä Xem k·∫øt qu·∫£" : "‚û°Ô∏è V√†o l√†m";

    c.innerHTML = `
      <div class="row1">
        <p class="vi">Xin ch√†o, <b>${escapeHtml(knownName)}</b> ${admin ? `<span class="adminBadgeInline">ADMIN</span>` : ``}</p>
        <div class="meta"><span class="idx">READY</span></div>
      </div>
      <div class="muted" style="margin-top:6px; line-height:1.35">
        B·∫•m <b>${escapeHtml(buttonLabel)}</b> ƒë·ªÉ v√†o b√†i.
      </div>

      ${QUIZ_LOADED && QUIZ.requireAccessCode ? `
        <div style="margin-top:10px; display:grid; gap:10px;">
          <div class="charRow"><div><b>M√£ truy c·∫≠p</b></div><div class="muted">(n·∫øu c√≥)</div></div>
          <input id="codeInput" class="input" placeholder="M√£ truy c·∫≠p" maxlength="32" value="${escapeHtml(state.accessCode||"")}" />
        </div>
      ` : ``}

      <div style="margin-top:10px; display:grid; gap:10px;">
        <button id="btnEnter" class="btn btn-primary" style="justify-content:center;" disabled>${escapeHtml(buttonLabel)}</button>
        <div class="muted" id="gateStatus">${escapeHtml(GATE.status || "")}</div>
      </div>
    `;
    content.appendChild(c);

    const codeInput = c.querySelector("#codeInput");
    if (codeInput) {
      codeInput.addEventListener("input", () => {
        state.accessCode = String(codeInput.value || "").trim();
        scheduleSave({ mirror: true });
      }, { passive: true });
    }

    const btnEnter = c.querySelector("#btnEnter");
    btnEnter.addEventListener("click", () => {
      if (!QUIZ_LOADED) { toast("ƒêang t·∫£i ƒë·ªÅ‚Ä¶"); return; }
      if (QUIZ.requireAccessCode && !String(state.accessCode||"").trim()){
        toast("Thi·∫øu m√£ truy c·∫≠p.");
        return;
      }

      if (state.finalized) renderResultView();
      else renderQuizView();

      document.getElementById("shell").scrollTo({ top: 0, behavior: "smooth" });
    });

    setGateReady(GATE.ready);
    setGateStatus(GATE.status);
    return;
  }

  // USERNAME INPUT MODE
  c.innerHTML = `
    <div class="row1">
      <p class="vi">Nh·∫≠p USERNAME</p>
      <div class="meta"><span class="idx">B·∫ÆT BU·ªòC</span></div>
    </div>
    <div class="muted" style="margin-top:6px; line-height:1.35">
      T·ªëi ƒëa 15 k√Ω t·ª±, ch·ªâ a-z A-Z 0-9 v√† d·∫•u _.<br/>
      - N·∫øu username <b>ƒë√£ c√≥</b> ‚Üí hi·ªán m√†n h√¨nh <b>ƒëƒÉng nh·∫≠p</b>.<br/>
      - N·∫øu username <b>ch∆∞a c√≥</b> ‚Üí hi·ªán th√¥ng b√°o v√† cho <b>ƒëƒÉng k√Ω</b>.
    </div>

    <div style="margin-top:10px; display:grid; gap:10px;">
      <input id="nameInput" class="input" placeholder="vd: tuankhoi123" autocomplete="off" maxlength="15" />
      <button id="btnSaveName" class="btn btn-primary" style="justify-content:center;">‚û°Ô∏è Ti·∫øp t·ª•c</button>
      <div class="muted" id="gateStatus">${escapeHtml(GATE.status || "")}</div>
    </div>
  `;
  content.appendChild(c);

  const nameInput = c.querySelector("#nameInput");
  const saveBtn = c.querySelector("#btnSaveName");
  try { nameInput.focus(); } catch(e){}

  async function finalizeLogin_(u, serverUserId){
    // u c√≥ th·ªÉ l√† user object (t·ª´ server) ho·∫∑c object fake khi fallback
    if (!u || !u.username) { toast("ƒêƒÉng nh·∫≠p l·ªói"); return; }

    USER = {
      userId: u.userId || serverUserId || randId("u"),
      username: u.username,
      lastRenameAtMs: u.lastRenameAtMs || 0
    };
    saveUser(USER);

    state.name = USER.username;
    state.cacheId = USER.userId;
    ensureCacheId();

    if (!state.attemptId) state.attemptId = randId("attempt");
    scheduleSave({ mirror: true });
    scheduleCloudSave();
    updateStats();

    if (QUIZ_LOADED) renderQuizView();
    else renderGateView();
  }

  async function flowLogin_(username, pinLen, serverUserId){
    setGateStatus("ƒêƒÉng nh·∫≠p: nh·∫≠p m·∫≠t kh·∫©u‚Ä¶");

    const u = await openPinModal_({
      username,
      mode:"login",
      pinLen,
      onSubmit: async (pin) => {
        if (!isDigitsOnly(pin)) return { ok:false, message:"M·∫≠t kh·∫©u ch·ªâ g·ªìm s·ªë" };

        // admin front-end fallback
        if (isAdminName(username)) {
          if (String(pin) !== ADMIN_PIN) return { ok:false, message:"Sai m·∫≠t kh·∫©u" };
        }

        // ‚úÖ try loginUser (g·ª≠i c·∫£ pin + password)
        try{
          const res = await apiLoginUser_(username, pin);
          const user = (res && res.user) ? res.user : res;
          const nu = normalizeUserObj_(user) || user;
          if (nu && nu.username) return { ok:true, data: nu };
          // n·∫øu server tr·∫£ format kh√°c -> v·∫´n cho qua minimal
          return { ok:true, data: { userId: serverUserId || randId("u"), username, lastRenameAtMs: 0 } };
        } catch(e){
          // ‚úÖ fallback: n·∫øu checkUsername tr·∫£ ƒë∆∞·ª£c password th√¨ verify t·∫°i client
          try{
            const ck = await apiCheckUsername_(username);
            const secret = extractServerPassword_(ck) || extractServerPassword_(ck && ck.user ? ck.user : null);
            const uid = pickUserId_(ck) || serverUserId || randId("u");

            if (secret && String(secret) === String(pin)) {
              return { ok:true, data: { userId: uid, username: String(username||"").trim(), lastRenameAtMs: Number(ck.lastRenameAtMs||0)||0 } };
            }
          } catch(_e){}
          return { ok:false, message:"Sai m·∫≠t kh·∫©u" };
        }
      }
    });

    await finalizeLogin_(u, serverUserId);
    toast("ƒêƒÉng nh·∫≠p th√†nh c√¥ng");
  }

  async function flowRegister_(username, pinLen, firstPin){
    setGateStatus("ƒêƒÉng k√Ω: t·∫°o m·∫≠t kh·∫©u‚Ä¶");

    const pin = await openPinModal_({ username, mode:"set", pinLen, firstPin: firstPin || "" });

    if (!isDigitsOnly(pin)) { toast("M·∫≠t kh·∫©u ch·ªâ g·ªìm s·ªë"); return; }
    if (String(pin).length !== pinLen) { toast(`M·∫≠t kh·∫©u ph·∫£i ${pinLen} s·ªë`); return; }

    if (isAdminName(username) && String(pin) !== ADMIN_PIN) {
      toast("T√†i kho·∫£n tuankhoi d√πng m·∫≠t kh·∫©u 6 s·ªë c·ªë ƒë·ªãnh");
      return;
    }

    setGateStatus("ƒêang t·∫°o t√†i kho·∫£n‚Ä¶");
    const res = await apiRegisterUser_(username, pin);

    const uRaw = res.user ? res.user : res;
    const u = normalizeUserObj_(uRaw) || uRaw;
    if (!u || !u.userId || !u.username) throw new Error("registerUser l·ªói.");

    USER = { userId: u.userId, username: u.username, lastRenameAtMs: u.lastRenameAtMs || 0 };
    saveUser(USER);

    state.name = USER.username;
    state.cacheId = USER.userId;
    ensureCacheId();

    if (!state.attemptId) state.attemptId = randId("attempt");
    scheduleSave({ mirror: true });
    scheduleCloudSave();
    updateStats();

    toast("ƒê√£ ƒëƒÉng k√Ω & ƒëƒÉng nh·∫≠p");
    if (QUIZ_LOADED) renderQuizView();
    else renderGateView();
  }

  const doFlow = async () => {
    let username = String(nameInput.value || "").trim();
    const err = validateUsername(username);
    if (err) { toast(err); return; }

    const defaultPinLen = isAdminName(username) ? 6 : 4;

    try {
      saveBtn.disabled = true;
      saveBtn.textContent = "‚è≥";
      setGateStatus("ƒêang ki·ªÉm tra username‚Ä¶");

      let exists = null;
      let serverUserId = "";
      let serverPinLen = 0;

      try {
        const ck = await apiCheckUsername_(username);
        exists = pickExists_(ck);
        serverUserId = pickUserId_(ck);
        serverPinLen = pickPinLen_(ck);
      } catch(e){
        exists = null;
      }

      if (exists === true) {
        const wantLen = serverPinLen || defaultPinLen;
        await flowLogin_(username, wantLen, serverUserId);
        return;
      }

      if (exists === false) {
        // ‚úÖ username ch∆∞a ƒëƒÉng k√Ω -> h·ªèi c√≥ mu·ªën ƒëƒÉng k√Ω kh√¥ng
        setGateStatus(`Username "${username}" ch∆∞a ƒëƒÉng k√Ω.`);
        const ok = await openRegisterPrompt_(username);
        if (!ok) {
          toast("B·∫°n c√≥ th·ªÉ nh·∫≠p username kh√°c");
          return;
        }
        await flowRegister_(username, defaultPinLen, "");
        return;
      }

      // fallback khi kh√¥ng check ƒë∆∞·ª£c
      setGateStatus("Kh√¥ng ki·ªÉm tra ƒë∆∞·ª£c. Th·ª≠ ƒëƒÉng nh·∫≠p‚Ä¶");
      const wantLen = serverPinLen || defaultPinLen;
      await flowLogin_(username, wantLen, serverUserId);
      return;

    } catch (e) {
      if (e && e.message === "cancel") {
      } else {
        toast((e && e.message) ? e.message : String(e));
      }
    } finally {
      saveBtn.disabled = false;
      saveBtn.textContent = "‚û°Ô∏è Ti·∫øp t·ª•c";
      setGateStatus(GATE.status || "S·∫µn s√†ng.");
    }
  };

  saveBtn.addEventListener("click", doFlow);
  nameInput.addEventListener("keydown", (e) => {
    if (e.key === "Enter") { e.preventDefault(); doFlow(); }
  });

  setGateReady(GATE.ready);
  setGateStatus(GATE.status);
}

/********************
 * Quiz rendering
 ********************/
function buildQuizHTML() {
  const order = state.order && state.order.length ? state.order : QUIZ.vocabs.map(v => v.id);
  let html = "";

  order.forEach((id, idx) => {
    const v = VMAP.get(id);
    if (!v) return;

    const displayNo = idx + 1;
    const typed = String(state.answers[id] ?? "");
    const checked = state.checked && state.checked[id];
    const locked = !!(checked && checked.locked);

    const resultHtml = (checked && checked.locked) ? `
      <div class="resultRow" data-result="${id}">
        <div>${checked.ok ? `<span class="oktxt">ƒê√öNG ‚úÖ</span>` : `<span class="badtxt">SAI ‚ùå</span>`}</div>
        <div>${checked.ok ? `` : `<span class="muted">ƒê√°p √°n:</span> <b>${escapeHtml(checked.expected || v.meaning || "")}</b>`}</div>
      </div>
    ` : ``;

    html += `
      <div class="card" data-qcard="${id}">
        <div class="row1">
          <p class="vi">C√¢u ${displayNo}. <b>${escapeHtml(v.word)}</b> <span class="muted">(${escapeHtml(v.pos||"")})</span></p>
          <div class="meta"><span class="idx">#${displayNo}</span></div>
        </div>

        <div style="margin-top:10px;">
          <div class="qaRow">
            <input class="input ansInput" data-qid="${id}" placeholder="Nh·∫≠p nghƒ©a‚Ä¶" value="${escapeHtml(typed)}" ${locked ? "disabled" : ""}/>
            <button class="btn btn-primary btn-check" data-check="${id}" ${locked ? "disabled" : ""}>
              ${locked ? "ƒê√£ check" : "Check"}
            </button>
          </div>
        </div>

        ${resultHtml}
      </div>
    `;
  });

  return html;
}

let handlersBound = false;
function renderQuizView() {
  setView("quiz");
  setDiscussFabVisible(false);

  if (!QUIZ_LOADED) { content.innerHTML = `<div class="card"><div class="vi">ƒêang t·∫£i ƒë·ªÅ‚Ä¶</div></div>`; return; }
  if (!state.name) { renderGateView(); return; }

  if (!state.attemptId) state.attemptId = randId("attempt");
  if (!state.order || !state.order.length) state.order = shuffle(QUIZ.vocabs.map(v => v.id));
  updateStats();

  content.innerHTML = buildQuizHTML();

  if (!handlersBound) {
    content.addEventListener("input", onInput, { passive: true });
    content.addEventListener("click", onClick);
    content.addEventListener("keydown", onKeyDown);
    content.addEventListener("focusout", onFocusOut, { passive: true });
    handlersBound = true;
  }
}

/********************
 * Auto-grade: ch·∫•m ng·∫ßm khi nh·∫≠p
 ********************/
const gradeTimers = new Map();
const gradeToken = new Map();
const gradeInFlight = new Set();
const lockAfterGrade = new Set();

function getCardEls_(id){
  const card = content.querySelector(`[data-qcard="${CSS.escape(String(id))}"]`);
  if (!card) return null;
  const input = card.querySelector(`.ansInput[data-qid="${CSS.escape(String(id))}"]`);
  const btn = card.querySelector(`[data-check="${CSS.escape(String(id))}"]`);
  const res = card.querySelector(`[data-result="${CSS.escape(String(id))}"]`);
  return { card, input, btn, res };
}

function ensureResultRow_(id, ok, expected){
  const els = getCardEls_(id);
  if (!els) return;
  const { card } = els;

  let row = card.querySelector(`[data-result="${CSS.escape(String(id))}"]`);
  if (!row) {
    row = document.createElement("div");
    row.className = "resultRow";
    row.setAttribute("data-result", String(id));
    card.appendChild(row);
  }
  row.innerHTML = `
    <div>${ok ? `<span class="oktxt">ƒê√öNG ‚úÖ</span>` : `<span class="badtxt">SAI ‚ùå</span>`}</div>
    <div>${ok ? `` : `<span class="muted">ƒê√°p √°n:</span> <b>${escapeHtml(expected || "")}</b>`}</div>
  `;
}

function lockUI_(id){
  const els = getCardEls_(id);
  if (!els) return;
  if (els.input) els.input.disabled = true;
  if (els.btn) {
    els.btn.disabled = true;
    els.btn.textContent = "ƒê√£ check";
  }
  const ck = state.checked[id];
  if (ck) ensureResultRow_(id, !!ck.ok, String(ck.expected||""));
}

async function gradeOne_(id, ans, { lock = false } = {}){
  if (!state.name) return;
  if (QUIZ.requireAccessCode && !String(state.accessCode||"").trim()) return;

  const akey = answerKey(ans);
  const existed = state.checked && state.checked[id];
  if (existed && existed.locked) return;

  if (existed && existed.lastKey === akey && !!existed.gradedAtMs) {
    if (lock && !existed.locked) {
      existed.locked = true;
      scheduleSave({ mirror: true });
      scheduleCloudSave();
      lockUI_(id);
    }
    return;
  }

  const token = randId("g");
  gradeToken.set(id, token);
  gradeInFlight.add(id);

  try {
    const res = await postJSON({
      action: "gradeOne",
      name: state.name,
      userId: USER && USER.userId ? USER.userId : "",
      quizId: QUIZ.quizId || getQuizId(),
      accessCode: state.accessCode || "",
      cacheId: state.cacheId,
      attemptId: state.attemptId,
      vocabId: id,
      answer: String(ans || "").trim(),
      ua: navigator.userAgent || ""
    });

    if (gradeToken.get(id) !== token) return;

    if (!res || !res.ok || !res.item) throw new Error("L·ªói ch·∫•m.");

    state.checked[id] = {
      locked: !!lock,
      ok: !!res.item.ok,
      expected: String(res.item.expected || ""),
      lastKey: akey,
      gradedAtMs: Date.now()
    };

    scheduleSave({ mirror: true });
    scheduleCloudSave();
    updateStats();

    if (lockAfterGrade.has(id)) {
      lockAfterGrade.delete(id);
      state.checked[id].locked = true;
      scheduleSave({ mirror: true });
      scheduleCloudSave();
      lockUI_(id);
      return;
    }

    if (lock) lockUI_(id);
  } catch (e) {
    if (lock) toast("Check l·ªói");
  } finally {
    gradeInFlight.delete(id);
  }
}

function scheduleAutoGrade_(id, delayMs = 550){
  if (gradeTimers.has(id)) clearTimeout(gradeTimers.get(id));
  const t = setTimeout(async () => {
    gradeTimers.delete(id);

    const ans = String(state.answers[id] ?? "").trim();
    const existed = state.checked && state.checked[id];
    if (existed && existed.locked) return;

    if (!ans) {
      if (existed && !existed.locked) {
        delete state.checked[id];
        scheduleSave({ mirror: true });
        scheduleCloudSave();
      }
      updateStats();
      return;
    }

    await gradeOne_(id, ans, { lock: false });
  }, delayMs);
  gradeTimers.set(id, t);
}

/********************
 * Events: input / enter / blur
 ********************/
function onInput(e) {
  const t = e.target;
  if (!t || !t.classList.contains("ansInput")) return;
  const id = Number(t.dataset.qid);
  if (!isFinite(id)) return;

  if (state.checked && state.checked[id] && state.checked[id].locked) {
    t.value = String(state.answers[id] ?? "");
    return;
  }

  state.answers[id] = String(t.value || "");
  scheduleSave();
  scheduleCloudSave();
  updateStats();

  scheduleAutoGrade_(id, 550);
}

function focusNextInput_(id){
  const inputs = Array.from(content.querySelectorAll(".ansInput"));
  const idx = inputs.findIndex(x => Number(x.dataset.qid) === Number(id));
  if (idx >= 0 && idx < inputs.length - 1) {
    try { inputs[idx + 1].focus({ preventScroll: false }); } catch(e){}
    try { inputs[idx + 1].scrollIntoView({ block: "nearest", behavior: "smooth" }); } catch(e){}
  }
}

function onKeyDown(e){
  const t = e.target;
  if (!t || !t.classList.contains("ansInput")) return;

  if (e.key === "Enter") {
    e.preventDefault();
    const id = Number(t.dataset.qid);
    if (!isFinite(id)) return;

    scheduleAutoGrade_(id, 0);
    focusNextInput_(id);
  }
}

function onFocusOut(e){
  const t = e.target;
  if (!t || !t.classList.contains("ansInput")) return;
  const id = Number(t.dataset.qid);
  if (!isFinite(id)) return;

  scheduleAutoGrade_(id, 0);
}

/********************
 * Click: Check
 ********************/
function onClick(e) {
  const btn = e.target.closest("[data-check]");
  if (!btn) return;

  const id = Number(btn.dataset.check);
  if (!isFinite(id)) return;

  if (!state.name) { toast("Thi·∫øu username"); renderGateView(); return; }
  if (!gasAvailable()) { toast("Thi·∫øu API_URL"); return; }
  if (QUIZ.requireAccessCode && !String(state.accessCode||"").trim()){
    toast("Thi·∫øu m√£ truy c·∫≠p.");
    renderGateView();
    return;
  }

  const existed = state.checked && state.checked[id];
  if (existed && existed.locked) return;

  const els = getCardEls_(id);
  const ans = els && els.input ? String(els.input.value || "").trim() : String(state.answers[id]||"").trim();
  state.answers[id] = ans;
  scheduleSave();
  scheduleCloudSave();

  if (!ans) { toast("Ch∆∞a nh·∫≠p"); return; }

  if (gradeInFlight.has(id)) {
    lockAfterGrade.add(id);
    btn.disabled = true;
    btn.textContent = "‚Ä¶";
    return;
  }

  const akey = answerKey(ans);
  if (existed && existed.lastKey === akey && !!existed.gradedAtMs) {
    existed.locked = true;
    scheduleSave({ mirror: true });
    scheduleCloudSave();
    lockUI_(id);
    toast(existed.ok ? "ƒê√öNG" : "SAI");
    updateStats();
    return;
  }

  btn.disabled = true;
  btn.textContent = "‚Ä¶";
  gradeOne_(id, ans, { lock: true }).then(() => {
    const ck = state.checked[id];
    if (ck) toast(ck.ok ? "ƒê√öNG" : "SAI");
  }).finally(() => {
    const ck = state.checked[id];
    if (!(ck && ck.locked)) {
      btn.disabled = false;
      btn.textContent = "Check";
    }
  });
}

/********************
 * Wrong popup
 ********************/
const wrongBackdrop = document.getElementById("wrongBackdrop");
const wrongBody = document.getElementById("wrongBody");
document.getElementById("btnCloseWrong").addEventListener("click", () => closeWrongPopup());
wrongBackdrop.addEventListener("click", (e) => { if (e.target === wrongBackdrop) closeWrongPopup(); });

function openWrongPopup() {
  wrongBackdrop.classList.add("show");
  wrongBackdrop.setAttribute("aria-hidden", "false");
}
function closeWrongPopup() {
  wrongBackdrop.classList.remove("show");
  wrongBackdrop.setAttribute("aria-hidden", "true");
}

function buildWrongPopupContent() {
  wrongBody.innerHTML = "";
  const r = state.result;
  if (!r) return;

  const wrong = r.wrong || [];
  if (!wrong.length) {
    wrongBody.innerHTML = `<div class="card"><span class="oktxt">Kh√¥ng sai ‚úÖ</span></div>`;
    return;
  }

  wrong.forEach((w) => {
    const box = document.createElement("div");
    box.className = "card";
    box.innerHTML = `
      <div class="row1">
        <p class="vi"><b>${escapeHtml(w.word || "")}</b></p>
        <div class="meta"><span class="idx">SAI</span></div>
      </div>
      <div style="margin-top:10px" class="muted">B·∫°n vi·∫øt: <b>${escapeHtml(w.user || "‚Äî")}</b></div>
      <div style="margin-top:6px">ƒê√°p √°n: <b>${escapeHtml(w.expected || "")}</b></div>
    `;
    wrongBody.appendChild(box);
  });
}

/********************
 * Leaderboard
 ********************/
async function fetchLeaderboard() {
  const box = document.getElementById("lbBox");
  if (!box) return;

  const meNorm = normalizeName(state.name);

  try {
    const res = await postJSON({ action: "getLeaderboard", limit: 30, quizId: QUIZ.quizId || getQuizId() });
    const rows = (res && res.rows) ? res.rows : [];
    if (!rows.length) {
      box.innerHTML = `<div class="muted">Ch∆∞a c√≥ d·ªØ li·ªáu.</div>`;
      return;
    }

    const uniqueRows = rows.slice(0, 30);

    box.innerHTML = `
      <table class="table">
        <colgroup>
          <col style="width:74px" />
          <col />
          <col style="width:92px" />
        </colgroup>
        <thead><tr><th>#</th><th>T√™n</th><th>ƒêi·ªÉm</th></tr></thead>
        <tbody>
          ${uniqueRows.map((r, index) => {
            const rk = index + 1;
            const medal = rk === 1 ? `<span class="medal m1">ü•á</span>` :
                          rk === 2 ? `<span class="medal m2">ü•à</span>` :
                          rk === 3 ? `<span class="medal m3">ü•â</span>` : "";
            const trClass = rk === 1 ? "toprow1" :
                            rk === 2 ? "toprow2" :
                            rk === 3 ? "toprow3" : "";
            const isMe = normalizeName(r.name) === meNorm;
            const rowClass = `${trClass} ${isMe ? "meRow" : ""}`.trim();

            const admin = !!r.isAdmin || isAdminName(r.name);
            const adminTag = admin ? `<span class="adminBadgeInline">ADMIN</span>` : ``;

            const nameCell = isMe
              ? `<span class="meName lbName">${escapeHtml(r.name)}</span><span class="meBadge">B·∫°n</span>${adminTag}`
              : `<span class="lbName">${escapeHtml(r.name)}</span>${adminTag}`;

            return `
              <tr class="${rowClass}">
                <td><span class="rankpill">${medal}<span>${rk}</span></span></td>
                <td>${nameCell}</td>
                <td><b>${Number(r.score10).toFixed(1)}</b>/10</td>
              </tr>
            `;
          }).join("")}
        </tbody>
      </table>
    `;
  } catch (err) {
    box.innerHTML = `L·ªói BXH: ${escapeHtml(err && err.message ? err.message : String(err))}`;
  }
}

/********************
 * Discussion - OPTIMISTIC UI
 ********************/
const DISCUSS_MAX = 120;

let DISCUSS = {
  loaded: false,
  loading: false,
  tree: []
};
let discussObserver = null;
let openReplyRootId = "";
const pendingTempIds = new Set();

/* tombstone deleted ids (per quiz) */
const DISCUSS_DELETED_KEY = () => `gs_discuss_deleted_v2::${getQuizId()}`;
let DELETED_IDS = new Set();

function loadDeletedIds_(){
  try {
    const raw = localStorage.getItem(DISCUSS_DELETED_KEY());
    const arr = JSON.parse(raw || "[]");
    if (Array.isArray(arr)) return new Set(arr.map(x => String(x)));
  } catch(e){}
  return new Set();
}
function saveDeletedIds_(){
  try { localStorage.setItem(DISCUSS_DELETED_KEY(), JSON.stringify(Array.from(DELETED_IDS))); } catch(e){}
}
function markDeleted_(id){
  const sid = String(id||"").trim();
  if (!sid) return;
  DELETED_IDS.add(sid);
  saveDeletedIds_();
}
function isTempId_(id){
  return String(id||"").startsWith("tmp_");
}

function canDeleteComment_(c){
  const admin = isAdminName(state.name);
  if (admin) return true;
  return normalizeName(c.author) === normalizeName(state.name);
}

function collectIdsFromTree_(tree){
  const ids = new Set();
  for (const r of (tree||[])) {
    ids.add(String(r.id));
    for (const rr of (r.replies||[])) ids.add(String(rr.id));
  }
  return ids;
}

function filterTreeByDeleted_(tree){
  const out = [];
  for (const root of (tree||[])) {
    const rid = String(root.id);
    if (DELETED_IDS.has(rid)) continue;

    const replies = Array.isArray(root.replies) ? root.replies : [];
    const keptReplies = replies.filter(r => {
      const id = String(r.id);
      const pid = String(r.parentId || root.id || "");
      if (DELETED_IDS.has(id)) return false;
      if (pid && DELETED_IDS.has(pid)) return false;
      return true;
    });

    out.push({
      ...root,
      replies: keptReplies
    });
  }
  return out;
}

function dedupeTree_(tree){
  const seen = new Set();
  const out = [];
  for (const root of (tree||[])) {
    const rid = String(root.id);
    if (seen.has(rid)) continue;
    seen.add(rid);

    const rseen = new Set();
    const replies = [];
    for (const r of (root.replies || [])) {
      const id = String(r.id);
      if (rseen.has(id)) continue;
      rseen.add(id);
      replies.push(r);
    }

    out.push({ ...root, replies });
  }
  return out;
}

function normalizeTreeFromServer_(res){
  if (res && Array.isArray(res.tree)) {
    const roots = res.tree.map(root => ({
      id: String(root.id),
      parentId: String(root.parentId||""),
      author: String(root.author||""),
      createdAtMs: Number(root.createdAtMs||0) || Date.now(),
      text: String(root.text||""),
      replies: Array.isArray(root.replies) ? root.replies.map(r => ({
        id: String(r.id),
        parentId: String(r.parentId || root.id || ""),
        author: String(r.author||""),
        createdAtMs: Number(r.createdAtMs||0) || Date.now(),
        text: String(r.text||""),
        replies: [],
        pending: !!r.pending
      })) : [],
      pending: !!root.pending
    }));
    roots.sort((a,b)=>a.createdAtMs-b.createdAtMs);
    roots.forEach(r=>r.replies.sort((a,b)=>a.createdAtMs-b.createdAtMs));
    return roots;
  }

  const flat = (res && Array.isArray(res.comments)) ? res.comments : [];
  const roots = [];
  const byId = new Map();
  for (const c of flat) {
    const id = String(c.id);
    if (!id) continue;
    if (byId.has(id)) continue;
    byId.set(id, {
      id,
      parentId: String(c.parentId||""),
      author: String(c.author||""),
      createdAtMs: Number(c.createdAtMs||0) || Date.now(),
      text: String(c.text||""),
      replies: []
    });
  }
  for (const c of byId.values()) {
    if (c.parentId && byId.has(c.parentId)) {
      const p = byId.get(c.parentId);
      if (p.parentId) roots.push(c);
      else p.replies.push(c);
    } else {
      roots.push(c);
    }
  }
  roots.sort((a,b)=>a.createdAtMs-b.createdAtMs);
  roots.forEach(r=>r.replies.sort((a,b)=>a.createdAtMs-b.createdAtMs));
  return roots;
}

function getDiscussionEls_(){
  return {
    section: document.getElementById("discussionSection"),
    list: document.getElementById("discussList"),
    rootInput: document.getElementById("rootInput"),
    rootCount: document.getElementById("rootCount"),
    btnPostRoot: document.getElementById("btnPostRoot"),
  };
}

function renderDiscuss_(){
  const { list, rootCount, rootInput } = getDiscussionEls_();
  if (!list) return;

  if (!DISCUSS.loaded && DISCUSS.loading) {
    list.innerHTML = `<div class="muted">ƒêang t·∫£i‚Ä¶</div>`;
    return;
  }

  const tree = Array.isArray(DISCUSS.tree) ? DISCUSS.tree : [];
  if (!tree.length) {
    list.innerHTML = `<div class="muted">Ch∆∞a c√≥ b√¨nh lu·∫≠n n√†o.</div>`;
  } else {
    list.innerHTML = "";
    tree.forEach(root => {
      const wrap = document.createElement("div");
      wrap.className = "cmtItem";

      const admin = isAdminName(root.author);
      const canDel = canDeleteComment_(root);
      const timeLabel = root.pending ? "‚Ä¶" : formatTs(root.createdAtMs);

      wrap.innerHTML = `
        <div class="cmtHead">
          <div class="cmtAuthor">
            <span>${escapeHtml(root.author || "‚Äî")}</span>
            ${admin ? `<span class="adminBadgeInline">ADMIN</span>` : ``}
          </div>
        </div>

        <div class="cmtText">${escapeHtml(root.text || "")}</div>

        <div class="cmtActions">
          <button class="cmtBtn" data-reply="${escapeHtml(root.id)}">Tr·∫£ l·ªùi</button>
          ${canDel ? `<button class="cmtBtn cmtBtnDanger" data-del="${escapeHtml(root.id)}">X√≥a</button>` : ``}
        </div>
        <div class="cmtTime">${escapeHtml(timeLabel)}</div>

        <div class="replySlot" data-slot="${escapeHtml(root.id)}"></div>
        <div class="replyWrap" data-replies="${escapeHtml(root.id)}"></div>
      `;
      list.appendChild(wrap);

      const slot = wrap.querySelector(`[data-slot="${CSS.escape(String(root.id))}"]`);
      if (slot && openReplyRootId === String(root.id)) {
        slot.innerHTML = `
          <div class="replyForm">
            <div class="charRow">
              <div><b>Tr·∫£ l·ªùi</b></div>
              <div><span data-ct>0</span>/${DISCUSS_MAX}</div>
            </div>
            <textarea class="input" rows="2" maxlength="${DISCUSS_MAX}" placeholder="Nh·∫≠p tr·∫£ l·ªùi..."></textarea>
            <div style="display:flex; justify-content:flex-end; gap:10px; flex-wrap:wrap;">
              <button class="btn btn-primary" data-sendreply="${escapeHtml(root.id)}" style="justify-content:center;">G·ª≠i</button>
              <button class="btn btn-ghost" data-cancelreply style="justify-content:center;">H·ªßy</button>
            </div>
          </div>
        `;
      }

      const rWrap = wrap.querySelector(`[data-replies="${CSS.escape(String(root.id))}"]`);
      const replies = Array.isArray(root.replies) ? root.replies : [];
      if (rWrap) {
        if (!replies.length) {
          rWrap.innerHTML = "";
        } else {
          rWrap.innerHTML = "";
          replies.forEach(r => {
            const item = document.createElement("div");
            item.className = "cmtItem";
            item.style.margin = "0";

            const rAdmin = isAdminName(r.author);
            const rCanDel = canDeleteComment_(r);
            const rTimeLabel = r.pending ? "‚Ä¶" : formatTs(r.createdAtMs);

            item.innerHTML = `
              <div class="cmtHead">
                <div class="cmtAuthor">
                  <span>${escapeHtml(r.author || "‚Äî")}</span>
                  ${rAdmin ? `<span class="adminBadgeInline">ADMIN</span>` : ``}
                </div>
              </div>

              <div class="cmtText">${escapeHtml(r.text || "")}</div>

              <div class="cmtActions">
                ${rCanDel ? `<button class="cmtBtn cmtBtnDanger" data-del="${escapeHtml(r.id)}">X√≥a</button>` : ``}
              </div>
              <div class="cmtTime">${escapeHtml(rTimeLabel)}</div>
            `;
            rWrap.appendChild(item);
          });
        }
      }
    });
  }

  if (rootInput && rootCount) rootCount.textContent = String((rootInput.value||"").length);
}

function removeNodeById_(id){
  const tree = DISCUSS.tree || [];
  const nid = String(id);

  for (const root of tree) {
    if (Array.isArray(root.replies)) {
      const before = root.replies.length;
      root.replies = root.replies.filter(r => String(r.id) !== nid);
      if (root.replies.length !== before) return true;
    }
  }
  const beforeRoots = tree.length;
  DISCUSS.tree = tree.filter(r => String(r.id) !== nid);
  return DISCUSS.tree.length !== beforeRoots;
}
function isValidDiscussText_(t){
  t = String(t||"").trim();
  if (!t) return false;
  if (t.length > DISCUSS_MAX) return false;
  return true;
}

async function ensureDiscussionLoaded_(force=false){
  if (!state.finalized) return;
  if (DISCUSS.loading) return;
  if (DISCUSS.loaded && !force) return;

  DISCUSS.loading = true;
  renderDiscuss_();

  const pendingKeep = [];
  for (const r of (DISCUSS.tree || [])) {
    if (r && r.pending && pendingTempIds.has(String(r.id))) pendingKeep.push(JSON.parse(JSON.stringify(r)));
    for (const rr of (r.replies || [])) {
      if (rr && rr.pending && pendingTempIds.has(String(rr.id))) pendingKeep.push(JSON.parse(JSON.stringify(rr)));
    }
  }

  try {
    const res = await postJSON({ action:"getComments", quizId: getQuizId() });
    let tree = normalizeTreeFromServer_(res);

    const serverIds = collectIdsFromTree_(tree);
    let changed = false;
    for (const did of Array.from(DELETED_IDS)) {
      if (!serverIds.has(String(did))) { DELETED_IDS.delete(String(did)); changed = true; }
    }
    if (changed) saveDeletedIds_();

    tree = filterTreeByDeleted_(tree);
    tree = dedupeTree_(tree);

    const nowIds = collectIdsFromTree_(tree);
    for (const p of pendingKeep) {
      if (!p || !p.id) continue;
      const pid = String(p.id);
      if (nowIds.has(pid)) continue;
      if (DELETED_IDS.has(pid)) continue;

      if (!p.parentId) {
        tree.push(p);
      } else {
        const root = tree.find(x => String(x.id) === String(p.parentId));
        if (root) {
          root.replies = Array.isArray(root.replies) ? root.replies : [];
          root.replies.push(p);
        } else {
          tree.push({ ...p, parentId:"", replies: Array.isArray(p.replies)?p.replies:[] });
        }
      }
    }

    tree.sort((a,b)=>Number(a.createdAtMs||0)-Number(b.createdAtMs||0));
    tree.forEach(r => (r.replies||[]).sort((a,b)=>Number(a.createdAtMs||0)-Number(b.createdAtMs||0)));

    DISCUSS.tree = tree;
    DISCUSS.loaded = true;
  } catch (e) {
    toast("Kh√¥ng t·∫£i ƒë∆∞·ª£c b√¨nh lu·∫≠n");
  } finally {
    DISCUSS.loading = false;
    renderDiscuss_();
  }
}

async function optimisticAddComment_({ text, parentId }){
  const trimmed = String(text||"").trim();
  if (!isValidDiscussText_(trimmed)) { toast("N·ªôi dung kh√¥ng h·ª£p l·ªá"); return; }
  if (!state.name) { toast("Thi·∫øu username"); return; }

  const tempId = "tmp_" + randId("c");
  pendingTempIds.add(tempId);

  const node = {
    id: tempId,
    parentId: String(parentId||""),
    author: state.name,
    createdAtMs: Date.now(),
    text: trimmed,
    replies: [],
    pending: true
  };

  DISCUSS.tree = Array.isArray(DISCUSS.tree) ? DISCUSS.tree : [];
  if (!node.parentId) {
    DISCUSS.tree.push(node);
  } else {
    const root = (DISCUSS.tree||[]).find(x => String(x.id) === String(node.parentId));
    if (root) {
      root.replies = Array.isArray(root.replies) ? root.replies : [];
      root.replies.push(node);
    } else {
      DISCUSS.tree.push({ ...node, parentId:"" });
    }
  }

  (DISCUSS.tree||[]).sort((a,b)=>a.createdAtMs-b.createdAtMs);
  (DISCUSS.tree||[]).forEach(r => (r.replies||[]).sort((a,b)=>a.createdAtMs-b.createdAtMs));
  renderDiscuss_();

  try {
    const res = await postJSON({
      action:"addComment",
      quizId: getQuizId(),
      userId: (USER && USER.userId) ? USER.userId : "",
      name: state.name,
      text: trimmed,
      parentId: node.parentId
    });

    const srv = res && res.comment ? res.comment : null;
    if (!srv || !srv.id) throw new Error("addComment l·ªói");

    const realId = String(srv.id);

    if (DELETED_IDS.has(tempId)) {
      pendingTempIds.delete(tempId);
      removeNodeById_(tempId);
      renderDiscuss_();
      return;
    }

    const tree = DISCUSS.tree || [];
    for (const root of tree) {
      if (String(root.id) === tempId) {
        root.id = realId;
        root.createdAtMs = Number(srv.createdAtMs||root.createdAtMs) || root.createdAtMs;
        root.pending = false;
        pendingTempIds.delete(tempId);
        renderDiscuss_();
        return;
      }
      for (const r of (root.replies||[])) {
        if (String(r.id) === tempId) {
          r.id = realId;
          r.createdAtMs = Number(srv.createdAtMs||r.createdAtMs) || r.createdAtMs;
          r.pending = false;
          pendingTempIds.delete(tempId);
          renderDiscuss_();
          return;
        }
      }
    }

    pendingTempIds.delete(tempId);
    await ensureDiscussionLoaded_(true);
  } catch (e) {
    pendingTempIds.delete(tempId);
    removeNodeById_(tempId);
    renderDiscuss_();
    toast("G·ª≠i l·ªói");
  }
}

async function optimisticDeleteComment_(id){
  if (!state.name) { toast("Thi·∫øu username"); return; }
  const sid = String(id||"").trim();
  if (!sid) return;

  const ok = confirm("X√≥a b√¨nh lu·∫≠n n√†y?");
  if (!ok) return;

  if (String(sid).startsWith("tmp_") && pendingTempIds.has(sid)) {
    pendingTempIds.delete(sid);
    removeNodeById_(sid);
    renderDiscuss_();
    toast("ƒê√£ x√≥a");
    return;
  }

  markDeleted_(sid);

  removeNodeById_(sid);
  renderDiscuss_();
  toast("ƒê√£ x√≥a");

  try {
    await postJSON({
      action:"deleteComment",
      quizId: getQuizId(),
      userId: (USER && USER.userId) ? USER.userId : "",
      name: state.name,
      id: sid
    });
  } catch (e) {}

  setTimeout(() => { ensureDiscussionLoaded_(true); }, 650);
}

function bindDiscussionEvents_(){
  const { rootInput, btnPostRoot, rootCount, section } = getDiscussionEls_();
  if (!section || !rootInput || !btnPostRoot || !rootCount) return;

  rootInput.addEventListener("input", () => {
    rootCount.textContent = String((rootInput.value||"").length);
  }, { passive:true });

  btnPostRoot.addEventListener("click", () => {
    const text = String(rootInput.value||"").trim();
    if (!isValidDiscussText_(text)) { toast("T·ªëi ƒëa 120 k√Ω t·ª±"); return; }
    rootInput.value = "";
    rootCount.textContent = "0";
    optimisticAddComment_({ text, parentId:"" });
  });

  section.addEventListener("click", (e) => {
    const delBtn = e.target.closest("[data-del]");
    if (delBtn) {
      const id = String(delBtn.getAttribute("data-del")||"");
      if (!id) return;
      optimisticDeleteComment_(id);
      return;
    }

    const replyBtn = e.target.closest("[data-reply]");
    if (replyBtn) {
      const rootId = String(replyBtn.getAttribute("data-reply")||"");
      openReplyRootId = (openReplyRootId === rootId) ? "" : rootId;
      renderDiscuss_();

      const slot = section.querySelector(`[data-slot="${CSS.escape(rootId)}"]`);
      const ta = slot ? slot.querySelector("textarea") : null;
      if (ta) ta.focus();
      return;
    }

    const cancelBtn = e.target.closest("[data-cancelreply]");
    if (cancelBtn) {
      openReplyRootId = "";
      renderDiscuss_();
      return;
    }

    const sendBtn = e.target.closest("[data-sendreply]");
    if (sendBtn) {
      const rootId = String(sendBtn.getAttribute("data-sendreply")||"");
      const slot = section.querySelector(`[data-slot="${CSS.escape(rootId)}"]`);
      const ta = slot ? slot.querySelector("textarea") : null;
      const text = ta ? String(ta.value||"").trim() : "";
      if (!isValidDiscussText_(text)) { toast("T·ªëi ƒëa 120 k√Ω t·ª±"); return; }
      openReplyRootId = "";
      renderDiscuss_();
      optimisticAddComment_({ text, parentId: rootId });
      return;
    }
  });

  section.addEventListener("input", (e) => {
    const ta = e.target;
    if (!(ta && ta.tagName === "TEXTAREA")) return;
    const form = ta.closest(".replyForm");
    if (!form) return;
    const ct = form.querySelector("[data-ct]");
    if (ct) ct.textContent = String((ta.value||"").length);
  }, { passive:true });
}

function attachDiscussionObserver_(){
  if (discussObserver) {
    try { discussObserver.disconnect(); } catch(e){}
    discussObserver = null;
  }
  const sec = document.getElementById("discussionSection");
  if (!sec) return;

  discussObserver = new IntersectionObserver((entries) => {
    for (const ent of entries) {
      if (ent.isIntersecting) ensureDiscussionLoaded_();
    }
  }, { root: document.getElementById("shell"), threshold: 0.15 });

  discussObserver.observe(sec);
}

/********************
 * Result view
 ********************/
function renderResultView() {
  setView("result");
  setDiscussFabVisible(true);

  content.innerHTML = "";
  const r = state.result;

  const sum = document.createElement("div");
  sum.className = "card";

  if (!r) {
    sum.innerHTML = `
      <div class="row1">
        <p class="vi">K·∫øt qu·∫£</p>
        <div class="meta"><span class="idx">ƒêANG T√çNH</span></div>
      </div>
      <div class="muted" style="margin-top:10px; line-height:1.35">
        ƒêang t√≠nh ƒëi·ªÉm...
      </div>
    `;
  } else {
    sum.innerHTML = `
      <div class="row1">
        <p class="vi">K·∫øt qu·∫£</p>
        <div class="meta"><span class="idx">DONE</span></div>
      </div>
      <div style="margin-top:10px; display:grid; gap:8px;">
        <div class="pill">ƒêi·ªÉm: <strong>${Number(r.score10).toFixed(1)}/10</strong></div>
        <div class="pill">ƒê√∫ng: <strong>${r.correctCount}</strong>/${r.totalCount}</div>
        <button class="btn btn-primary" id="btnShowWrong" style="justify-content:center;">üìå Xem c√¢u sai</button>
      </div>
    `;
  }
  content.appendChild(sum);

  const lb = document.createElement("div");
  lb.className = "card";
  lb.innerHTML = `
    <div class="row1">
      <p class="vi">B·∫£ng x·∫øp h·∫°ng</p>
      <div class="meta"><span class="idx">TOP</span></div>
    </div>
    <div id="lbBox" class="muted" style="margin-top:10px; overflow-x:hidden;">ƒêang t·∫£i‚Ä¶</div>
  `;
  content.appendChild(lb);

  const discuss = document.createElement("div");
  discuss.className = "card";
  discuss.id = "discussionSection";
  discuss.innerHTML = `
    <div class="row1">
      <p class="vi">Th·∫£o lu·∫≠n</p>
      <div class="meta"><span class="idx">üí¨</span></div>
    </div>

    <div style="margin-top:10px; display:grid; gap:10px;">
      <div class="charRow">
        <div><b>Vi·∫øt b√¨nh lu·∫≠n</b></div>
        <div><span id="rootCount">0</span>/${DISCUSS_MAX}</div>
      </div>
      <textarea id="rootInput" class="input" rows="3" maxlength="${DISCUSS_MAX}" placeholder="Nh·∫≠p b√¨nh lu·∫≠n..."></textarea>
      <div style="display:flex; justify-content:flex-end; gap:10px; flex-wrap:wrap;">
        <button class="btn btn-primary" id="btnPostRoot" style="justify-content:center;">‚ûï G·ª≠i</button>
      </div>
      <div id="discussList" class="cmtBox"></div>
    </div>
  `;
  content.appendChild(discuss);

  if (r) {
    document.getElementById("btnShowWrong").addEventListener("click", () => {
      buildWrongPopupContent();
      openWrongPopup();
    });
  }

  fetchLeaderboard();

  DISCUSS.loaded = false;
  DISCUSS.loading = false;
  DISCUSS.tree = [];
  openReplyRootId = "";

  renderDiscuss_();
  bindDiscussionEvents_();
  attachDiscussionObserver_();

  updateStats();
}

/********************
 * Submit
 ********************/
function getMissingQuestions_(){
  const order = state.order && state.order.length ? state.order : (QUIZ.vocabs||[]).map(v=>v.id);
  const missing = [];
  for (let i=0;i<order.length;i++){
    const id = order[i];
    const ans = String(state.answers[id] ?? "").trim();
    if (!ans) missing.push(i+1);
  }
  return missing;
}

async function flushPendingGrades_(){
  for (const [id, tm] of gradeTimers.entries()) {
    clearTimeout(tm);
    gradeTimers.delete(id);
  }

  const order = state.order && state.order.length ? state.order : (QUIZ.vocabs||[]).map(v=>v.id);
  const tasks = [];

  for (const id of order) {
    const ans = String(state.answers[id] ?? "").trim();
    if (!ans) continue;

    const ck = state.checked && state.checked[id];
    if (ck && ck.locked) continue;

    const akey = answerKey(ans);
    if (ck && ck.lastKey === akey && !!ck.gradedAtMs) continue;

    tasks.push(gradeOne_(id, ans, { lock: false }));
  }

  if (tasks.length) {
    try { await Promise.allSettled(tasks); } catch(e){}
  }
}

async function finalizeAttemptAsync_(){
  const res = await postJSON({
    action: "finalizeAttempt",
    name: state.name,
    userId: USER && USER.userId ? USER.userId : "",
    quizId: QUIZ.quizId || getQuizId(),
    accessCode: state.accessCode || "",
    cacheId: state.cacheId,
    attemptId: state.attemptId
  });
  return res;
}

document.getElementById("btnSubmit").addEventListener("click", () => {
  if (!state.name) { toast("Thi·∫øu username"); renderGateView(); return; }
  if (state.finalized) return;

  const missing = getMissingQuestions_();
  if (missing.length) {
    let msg = "";
    if (missing.length > 5) {
      msg = `B·∫°n c√≤n ${missing.length} c√¢u ch∆∞a l√†m ho·∫∑c nhi·ªÅu h∆°n.\nN·ªôp v·∫´n t√≠nh sai c√°c c√¢u ƒë√≥.\n\nN·ªôp b√†i?`;
    } else {
      msg = `B·∫°n c√≤n c√¢u ${missing.join(", ")} ch∆∞a l√†m.\nN·ªôp v·∫´n t√≠nh sai c√°c c√¢u ƒë√≥.\n\nN·ªôp b√†i?`;
    }
    const ok = confirm(msg);
    if (!ok) return;
  }

  state.finalized = true;
  state.result = null;
  scheduleSave({ mirror: true });
  scheduleCloudSave();
  renderResultView();
  toast("ƒêang t√≠nh ƒëi·ªÉm...");

  setTimeout(async () => {
    try {
      await flushPendingGrades_();

      const res = await finalizeAttemptAsync_();
      if (!res || !res.ok || !res.result) throw new Error("Finalize l·ªói");

      state.result = res.result;

      state.history = Array.isArray(state.history) ? state.history : [];
      state.history.push({
        ts: Date.now(),
        score10: state.result.score10,
        correctCount: state.result.correctCount,
        totalCount: state.result.totalCount
      });

      scheduleSave({ mirror: true });
      scheduleCloudSave();

      renderResultView();
      toast("Xong");
    } catch (e) {
      state.finalized = false;
      state.result = null;
      scheduleSave({ mirror: true });
      scheduleCloudSave();
      toast("N·ªôp l·ªói, th·ª≠ l·∫°i");
      renderQuizView();
    } finally {
      updateStats();
    }
  }, 0);
});

/********************
 * Reset
 ********************/
const modal = document.getElementById("modalBackdrop");
const openModal = () => { modal.classList.add("show"); modal.setAttribute("aria-hidden", "false"); };
const closeModal = () => { modal.classList.remove("show"); modal.setAttribute("aria-hidden", "true"); };

document.getElementById("btnReset").addEventListener("click", openModal);
document.getElementById("btnCancel").addEventListener("click", closeModal);
modal.addEventListener("click", (e) => { if (e.target === modal) closeModal(); });

document.getElementById("btnConfirmReset").addEventListener("click", () => {
  closeModal();
  const keepName = state.name;
  const keepCache = state.cacheId;
  const keepHist = Array.isArray(state.history) ? state.history : [];
  const keepCode = state.accessCode || "";

  state = {
    quizVersion: QUIZ_VERSION,
    cacheId: keepCache,
    name: keepName,
    accessCode: keepCode,
    attemptId: "",
    order: [],
    answers: {},
    checked: {},
    finalized: false,
    result: null,
    history: keepHist,
    ts: Date.now()
  };
  newAttempt();
  scheduleSave({ mirror: true });
  scheduleCloudSave();
  toast("ƒê√£ l√†m l·∫°i");

  GATE.ready = true;
  GATE.status = "S·∫µn s√†ng.";
  renderGateView();
  updateStats();
});

/********************
 * Scroll top
 ********************/
document.getElementById("btnScrollTop").addEventListener("click", () => {
  document.getElementById("shell").scrollTo({ top: 0, behavior: "smooth" });
});

/********************
 * Discuss button
 ********************/
document.getElementById("btnDiscuss").addEventListener("click", async () => {
  if (!state.finalized) return;
  const sec = document.getElementById("discussionSection");
  if (!sec) return;

  await ensureDiscussionLoaded_();
  sec.scrollIntoView({ behavior: "smooth", block: "start" });

  setTimeout(() => {
    const { rootInput } = getDiscussionEls_();
    if (rootInput) rootInput.focus();
  }, 350);
});

/********************
 * UserCorner click -> Profile
 ********************/
document.getElementById("userCorner").addEventListener("click", () => {
  if (!state.name) return;
  openProfileModal_();
});

/********************
 * Profile actions
 ********************/

/* ‚úÖ ƒê·ªîI USERNAME: ch·∫∑n tuankhoi */
document.getElementById("btnSaveNewUsername").addEventListener("click", async () => {
  if (!state.name) return;

  // ‚úÖ tuankhoi kh√¥ng ƒë∆∞·ª£c ƒë·ªïi
  if (isAdminName(state.name)) {
    toast("T√†i kho·∫£n tuankhoi kh√¥ng ƒë∆∞·ª£c ƒë·ªïi username");
    return;
  }

  const newU = String(document.getElementById("newUsername").value||"").trim();
  const err = validateUsername(newU);
  if (err) { toast(err); return; }

  const oldName = state.name;
  if (normalizeForFilter(newU) === normalizeForFilter(oldName)) { toast("Tr√πng username hi·ªán t·∫°i"); return; }

  const last = Number((USER && USER.lastRenameAtMs) ? USER.lastRenameAtMs : 0) || 0;
  const now = Date.now();
  const DAY = 24*60*60*1000;
  if (last && (now - last < 30*DAY)) {
    toast("Ch∆∞a ƒë·ªß 30 ng√†y");
    return;
  }

  // check tr√πng (n·∫øu backend c√≥)
  try{
    const ck = await apiCheckUsername_(newU);
    if (ck && (ck.exists === true)) { toast("Username ƒë√£ t·ªìn t·∫°i"); return; }
  } catch(e){
  }

  const btn = document.getElementById("btnSaveNewUsername");
  const oldText = btn.textContent;

  // optimistic UI: ƒë·ªïi li·ªÅn cho m∆∞·ª£t
  btn.disabled = true;
  btn.textContent = "‚è≥";
  state.name = newU;
  if (USER) {
    USER.username = newU;
    USER.lastRenameAtMs = Date.now(); // ‚Äúl∆∞u ·∫£o‚Äù ƒë·ªÉ kh√≥a 30 ng√†y ngay
    saveUser(USER);
  }
  scheduleSave({ mirror:true });
  scheduleCloudSave();
  updateStats();
  closeProfileModal_();
  renderGateView();
  toast("ƒê√£ ƒë·ªïi username (ƒëang l∆∞u...)");

  try{
    const res = await apiChangeUsername_(oldName, newU);
    const uRaw = (res && res.user) ? res.user : res;
    const u = normalizeUserObj_(uRaw) || uRaw;

    const finalName = (u && u.username) ? u.username : newU;
    const finalLast = (u && u.lastRenameAtMs) ? u.lastRenameAtMs : (USER ? USER.lastRenameAtMs : Date.now());

    state.name = finalName;
    if (USER) {
      USER.username = finalName;
      USER.lastRenameAtMs = finalLast;
      saveUser(USER);
    }

    scheduleSave({ mirror:true });
    scheduleCloudSave();
    updateStats();
    renderGateView();
    toast("ƒê√£ l∆∞u username");
  } catch(e){
    // gi·ªØ local theo y√™u c·∫ßu ‚Äúgi·∫£ b·ªô l∆∞u ·∫£o‚Äù
    toast("Server ch∆∞a l∆∞u ƒë∆∞·ª£c, t·∫°m d√πng username m·ªõi tr√™n m√°y n√†y");
  } finally {
    btn.disabled = false;
    btn.textContent = oldText;
  }
});

/* ‚úÖ ƒê·ªîI M·∫¨T KH·∫®U: sai old pin => ƒë·ªè + rung, KH√îNG t·ª± t·∫Øt modal */
const btnChangePinEl = document.getElementById("btnChangePin");
btnChangePinEl.addEventListener("click", (e) => { e.preventDefault(); }, true);

btnChangePinEl.addEventListener("pointerdown", async (e) => {
  if (!state.name) return;
  if (btnChangePinEl.dataset.busy === "1") return;

  e.preventDefault();
  btnChangePinEl.dataset.busy = "1";

  const pinLen = isAdminName(state.name) ? 6 : 4;

  try{
    await openPinModal_({
      username: state.name,
      mode:"change",
      pinLen,
      onVerifyOld: async (oldPin) => {
        if (!isDigitsOnly(oldPin)) return { ok:false, message:"M·∫≠t kh·∫©u ch·ªâ g·ªìm s·ªë" };

        if (isAdminName(state.name)) {
          if (String(oldPin) !== ADMIN_PIN) return { ok:false, message:"Sai m·∫≠t kh·∫©u" };
          return { ok:true };
        }

        // verify b·∫±ng loginUser
        try{
          await apiLoginUser_(state.name, oldPin);
          return { ok:true };
        } catch(e){
          // fallback: th·ª≠ checkUsername n·∫øu c√≥ password tr·∫£ v·ªÅ
          try{
            const ck = await apiCheckUsername_(state.name);
            const secret = extractServerPassword_(ck) || extractServerPassword_(ck && ck.user ? ck.user : null);
            if (secret && String(secret) === String(oldPin)) return { ok:true };
          } catch(_e){}
          return { ok:false, message:"Sai m·∫≠t kh·∫©u" };
        }
      },
      onFinalizeChange: async ({ oldPin, newPin }) => {
        if (!isDigitsOnly(newPin)) return { ok:false, message:"M·∫≠t kh·∫©u ch·ªâ g·ªìm s·ªë", resetStep:"new1" };
        if (String(newPin).length !== pinLen) return { ok:false, message:`M·∫≠t kh·∫©u ph·∫£i ${pinLen} s·ªë`, resetStep:"new1" };

        if (isAdminName(state.name)) {
          // admin pin c·ªë ƒë·ªãnh -> kh√¥ng cho ƒë·ªïi
          return { ok:false, message:"T√†i kho·∫£n tuankhoi kh√¥ng cho ƒë·ªïi m·∫≠t kh·∫©u", resetStep:"old" };
        }

        try{
          await apiChangePassword_(state.name, oldPin, newPin);
          return { ok:true };
        } catch(e){
          return { ok:false, message:"Sai m·∫≠t kh·∫©u ho·∫∑c server l·ªói", resetStep:"old" };
        }
      }
    });

    closeProfileModal_();
    toast("ƒê√£ ƒë·ªïi m·∫≠t kh·∫©u");
  } catch(e){
    if (!(e && e.message === "cancel")) toast("ƒê·ªïi m·∫≠t kh·∫©u l·ªói");
  } finally {
    btnChangePinEl.dataset.busy = "0";
  }
}, { passive:false });

document.getElementById("btnLogout").addEventListener("click", async () => {
  const ok = confirm("ƒêƒÉng xu·∫•t?");
  if (!ok) return;

  try { saveUser(null); } catch(e){}
  USER = null;

  try { await Persist.remove(STORAGE_KEY); } catch(e){}

  state = {
    quizVersion: QUIZ_VERSION,
    cacheId: "",
    name: "",
    accessCode: "",
    attemptId: "",
    order: [],
    answers: {},
    checked: {},
    finalized: false,
    result: null,
    history: [],
    ts: Date.now()
  };

  try { location.hash = ""; } catch(e){}
  ensureCacheId();
  scheduleSave({ mirror:true });
  updateStats();

  closeProfileModal_();
  toast("ƒê√£ ƒëƒÉng xu·∫•t");
  renderGateView();
});

/********************
 * Load local state
 ********************/
async function tryLoadStateLocal(){
  let raw = null;
  try { raw = Persist.mirrorGet ? Persist.mirrorGet() : null; } catch (e) {}
  if (!raw && Persist.mode && Persist.mode.local) {
    try { raw = localStorage.getItem(STORAGE_KEY); } catch (e) {}
  }
  if (!raw && Persist.mode && Persist.mode.session) {
    try { raw = sessionStorage.getItem(STORAGE_KEY); } catch (e) {}
  }
  if (raw) {
    try {
      const parsed = JSON.parse(raw);
      if (parsed && typeof parsed === "object") state = parsed;
    } catch (e) {}
  }
}

/********************
 * Bootstrap load (1 call) with fallback
 ********************/
function applyQuiz_(quizData){
  if (!quizData) return;
  QUIZ = quizData || QUIZ;
  QUIZ.quizId = QUIZ.quizId || getQuizId();
  QUIZ_LOADED = true;

  document.getElementById("quizTitle").textContent = QUIZ.title || "Vocabulary";
  document.getElementById("quizSub").textContent = (QUIZ.sub || "").trim();
  VMAP = new Map((QUIZ.vocabs||[]).map(v => [v.id, v]));
}
function adoptStateFromServer_(serverStateJson){
  if (!serverStateJson) return;
  let serverState = null;
  try { serverState = JSON.parse(serverStateJson); } catch(e){ return; }
  if (!serverState || typeof serverState !== "object") return;

  const sTs = Number(serverState.ts || 0);
  const lTs = Number(state.ts || 0);

  if (!lTs && sTs) state = serverState;
  else if (sTs && sTs > lTs) state = serverState;
}

async function loadBootstrapOrFallback_(){
  try {
    const payload = {
      action: "bootstrap",
      quizId: getQuizId(),
      userId: (USER && USER.userId) ? USER.userId : "",
      name: (USER && USER.username) ? USER.username : (state.name || ""),
      username: (USER && USER.username) ? USER.username : (state.name || ""),
      cacheId: state.cacheId || ((USER && USER.userId) ? USER.userId : "")
    };
    const res = await postJSON(payload);

    if (res && res.quiz) applyQuiz_(res.quiz);
    else if (res && res.title && res.vocabs) applyQuiz_(res);

    if (res && res.me && res.me.user) {
      const uRaw = res.me.user;
      const u = normalizeUserObj_(uRaw) || uRaw;
      if (u && u.userId && u.username) {
        USER = { userId: u.userId, username: u.username, lastRenameAtMs: u.lastRenameAtMs || 0 };
        saveUser(USER);

        // ‚úÖ sync state.name ƒë·ªÉ tr√°nh l·ªách
        state.name = USER.username;
        state.cacheId = USER.userId;
      }
    }

    if (res && res.progress && res.progress.stateJson) {
      adoptStateFromServer_(res.progress.stateJson);
    }

    return;
  } catch(e){}

  const quizData = await postJSON({ action: "getQuizData", quizId: getQuizId() });
  applyQuiz_(quizData);

  if (state.cacheId) {
    try {
      const pr = await postJSON({ action: "getProgress", cacheId: state.cacheId });
      if (pr && pr.stateJson) adoptStateFromServer_(pr.stateJson);
    } catch(e){}
  }
}

/********************
 * Boot
 ********************/
function parseHashCacheId() {
  try {
    const h = String(location.hash || "").replace(/^#/, "");
    const m = h.match(/(?:^|&)cache=([^&]+)/);
    return m ? decodeURIComponent(m[1]) : null;
  } catch(e){ return null; }
}

(async function(){
  if (!gasAvailable()) {
    content.innerHTML = `<div class="card"><b>Thi·∫øu API_URL</b></div>`;
    return;
  }

  installGoogleScriptRunPolyfill();

  showBootLoading("ƒêang t·∫£i quiz, ƒë·ª£i x√≠u nha");

  try {
    setBootLoadingMsg("ƒêang chu·∫©n b·ªã‚Ä¶");
    await Persist.init();
    await tryLoadStateLocal();
  } catch(e){}

  try { USER = loadUser(); } catch(e){ USER = null; }

  DELETED_IDS = loadDeletedIds_();

  ensureCacheId();

  if (USER && USER.userId && USER.username) {
    state.name = USER.username;
    state.cacheId = USER.userId;
  }

  if (!state.cacheId) {
    const fromHash = parseHashCacheId();
    if (fromHash) state.cacheId = fromHash;
  }

  updateStats();
  scheduleSave({ mirror: true });

  try {
    setBootLoadingMsg("ƒêang t·∫£i ƒë·ªÅ‚Ä¶");
    await loadBootstrapOrFallback_();

    if (!state.attemptId) state.attemptId = randId("attempt");
    if (!state.order || !state.order.length) state.order = shuffle(QUIZ.vocabs.map(v => v.id));

    updateStats();
    scheduleSave({ mirror: true });

    GATE.ready = true;
    GATE.status = "S·∫µn s√†ng.";
  } catch (e) {
    GATE.ready = false;
    GATE.status = "L·ªói t·∫£i ƒë·ªÅ";
  }

  hideBootLoading();
  renderGateView();

  startCloudAutosave();

  window.addEventListener("pagehide", () => {
    try { Persist.mirrorToWindowName(JSON.stringify(state)); } catch (e) {}
    scheduleCloudSave();
  }, { passive: true });
})();
</script>
</body>
</html>
